SCRIPT  /usr/share/vim/vim81/ftplugin/ruby.vim
Sourced 1 time
Total time:   0.001177
 Self time:   0.000778

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Ruby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:  Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            
    1              0.000004 if (exists("b:did_ftplugin"))
                              finish
                            endif
    1              0.000002 let b:did_ftplugin = 1
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000005 if has("gui_running") && !has("gui_win32")
                              setlocal keywordprg=ri\ -T\ -f\ bs
                            else
    1              0.000003   setlocal keywordprg=ri
    1              0.000001 endif
                            
                            " Matchit support
    1              0.000003 if exists("loaded_matchit") && !exists("b:match_words")
                              let b:match_ignorecase = 0
                            
                              let b:match_words =
                            	\ '\<\%(if\|unless\|case\|while\|until\|for\|do\|class\|module\|def\|begin\)\>=\@!' .
                            	\ ':' .
                            	\ '\<\%(else\|elsif\|ensure\|when\|rescue\|break\|redo\|next\|retry\)\>' .
                            	\ ':' .
                                    \ '\%(^\|[^.\:@$]\)\@<=\<end\:\@!\>' .
                            	\ ',{:},\[:\],(:)'
                            
                              let b:match_skip =
                            	\ "synIDattr(synID(line('.'),col('.'),0),'name') =~ '" .
                            	\ "\\<ruby\\%(String\\|StringDelimiter\\|ASCIICode\\|Escape\\|" .
                                    \ "Regexp\\|RegexpDelimiter\\|" .
                            	\ "Interpolation\\|NoInterpolation\\|Comment\\|Documentation\\|" .
                            	\ "ConditionalModifier\\|RepeatModifier\\|OptionalDo\\|" .
                            	\ "Function\\|BlockArgument\\|KeywordAsMethod\\|ClassVariable\\|" .
                            	\ "InstanceVariable\\|GlobalVariable\\|Symbol\\)\\>'"
                            endif
                            
    1              0.000004 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000002 setlocal include=^\\s*\\<\\(load\\>\\\|require\\>\\\|autoload\\s*:\\=[\"']\\=\\h\\w*[\"']\\=,\\)
    1              0.000003 setlocal includeexpr=substitute(substitute(v:fname,'::','/','g'),'\%(\.rb\)\=$','.rb','')
    1              0.000002 setlocal suffixesadd=.rb
                            
    1              0.000004 if exists("&ofu") && has("ruby")
                              setlocal omnifunc=rubycomplete#Complete
                            endif
                            
                            " To activate, :set ballooneval
    1              0.000003 if has('balloon_eval') && exists('+balloonexpr')
    1              0.000002   setlocal balloonexpr=RubyBalloonexpr()
    1              0.000000 endif
                            
                            
                            " TODO:
                            "setlocal define=^\\s*def
                            
    1              0.000002 setlocal comments=:#
    1              0.000001 setlocal commentstring=#\ %s
                            
    1              0.000002 if !exists('g:ruby_version_paths')
                              let g:ruby_version_paths = {}
                            endif
                            
    1              0.000003 function! s:query_path(root) abort
                              let code = "print $:.join %q{,}"
                              if &shell =~# 'sh'
                                let prefix = 'env PATH='.shellescape($PATH).' '
                              else
                                let prefix = ''
                              endif
                              if &shellxquote == "'"
                                let path_check = prefix.'ruby --disable-gems -e "' . code . '"'
                              else
                                let path_check = prefix."ruby --disable-gems -e '" . code . "'"
                              endif
                            
                              let cd = haslocaldir() ? 'lcd' : 'cd'
                              let cwd = fnameescape(getcwd())
                              try
                                exe cd fnameescape(a:root)
                                let path = split(system(path_check),',')
                                exe cd cwd
                                return path
                              finally
                                exe cd cwd
                              endtry
                            endfunction
                            
    1              0.000001 function! s:build_path(path) abort
                              let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
                              if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
                                let path = substitute(&g:path,',,$',',','') . ',' . path
                              endif
                              return path
                            endfunction
                            
    1              0.000018 if !exists('b:ruby_version') && !exists('g:ruby_path') && isdirectory(expand('%:p:h'))
    1              0.000157   let s:version_file = findfile('.ruby-version', '.;')
    1              0.000003   if !empty(s:version_file) && filereadable(s:version_file)
                                let b:ruby_version = get(readfile(s:version_file, '', 1), '')
                                if !has_key(g:ruby_version_paths, b:ruby_version)
                                  let g:ruby_version_paths[b:ruby_version] = s:query_path(fnamemodify(s:version_file, ':p:h'))
                                endif
                              endif
    1              0.000001 endif
                            
    1              0.000002 if exists("g:ruby_path")
                              let s:ruby_path = type(g:ruby_path) == type([]) ? join(g:ruby_path, ',') : g:ruby_path
                            elseif has_key(g:ruby_version_paths, get(b:, 'ruby_version', ''))
                              let s:ruby_paths = g:ruby_version_paths[b:ruby_version]
                              let s:ruby_path = s:build_path(s:ruby_paths)
                            else
    1              0.000002   if !exists('g:ruby_default_path')
                                if has("ruby") && has("win32")
                                  ruby ::VIM::command( 'let g:ruby_default_path = split("%s",",")' % $:.join(%q{,}) )
                                elseif executable('ruby')
                                  let g:ruby_default_path = s:query_path($HOME)
                                else
                                  let g:ruby_default_path = map(split($RUBYLIB,':'), 'v:val ==# "." ? "" : v:val')
                                endif
                              endif
    1              0.000001   let s:ruby_paths = g:ruby_default_path
    1   0.000044   0.000013   let s:ruby_path = s:build_path(s:ruby_paths)
    1              0.000001 endif
                            
    1              0.000002 if stridx(&l:path, s:ruby_path) == -1
    1              0.000003   let &l:path = s:ruby_path
    1              0.000002 endif
    1              0.000013 if exists('s:ruby_paths') && stridx(&l:tags, join(map(copy(s:ruby_paths),'v:val."/tags"'),',')) == -1
    1              0.000014   let &l:tags = &tags . ',' . join(map(copy(s:ruby_paths),'v:val."/tags"'),',')
    1              0.000000 endif
                            
    1              0.000005 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
    1              0.000003   let b:browsefilter = "Ruby Source Files (*.rb)\t*.rb\n" .
                                                 \ "All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
    1              0.000005 let b:undo_ftplugin = "setl fo< inc< inex< sua< def< com< cms< path< tags< kp<"
                                  \."| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"
                                  \."| if exists('&ofu') && has('ruby') | setl ofu< | endif"
                                  \."| if has('balloon_eval') && exists('+bexpr') | setl bexpr< | endif"
                            
    1              0.000003 function! s:map(mode, flags, map) abort
                              let from = matchstr(a:map, '\S\+')
                              if empty(mapcheck(from, a:mode))
                                exe a:mode.'map' '<buffer>'.(a:0 ? a:1 : '') a:map
                                let b:undo_ftplugin .= '|sil! '.a:mode.'unmap <buffer> '.from
                              endif
                            endfunction
                            
    1              0.000021 cmap <buffer><script><expr> <Plug><cword> substitute(RubyCursorIdentifier(),'^$',"\022\027",'')
    1              0.000011 cmap <buffer><script><expr> <Plug><cfile> substitute(RubyCursorFile(),'^$',"\022\006",'')
    1              0.000003 let b:undo_ftplugin .= "| sil! cunmap <buffer> <Plug><cword>| sil! cunmap <buffer> <Plug><cfile>"
                            
    1              0.000002 if !exists("g:no_plugin_maps") && !exists("g:no_ruby_maps")
    1              0.000006   nmap <buffer><script> <SID>:  :<C-U>
    1              0.000007   nmap <buffer><script> <SID>c: :<C-U><C-R>=v:count ? v:count : ''<CR>
                            
    1              0.000009   nnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','n')<CR>
    1              0.000008   nnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','n')<CR>
    1              0.000007   nnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','n')<CR>
    1              0.000007   nnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','n')<CR>
    1              0.000007   xnoremap <silent> <buffer> [m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','b','v')<CR>
    1              0.000007   xnoremap <silent> <buffer> ]m :<C-U>call <SID>searchsyn('\<def\>','rubyDefine','','v')<CR>
    1              0.000008   xnoremap <silent> <buffer> [M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','b','v')<CR>
    1              0.000007   xnoremap <silent> <buffer> ]M :<C-U>call <SID>searchsyn('\<end\>','rubyDefine','','v')<CR>
                            
    1              0.000012   nnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','n')<CR>
    1              0.000011   nnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','n')<CR>
    1              0.000009   nnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','n')<CR>
    1              0.000008   nnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','n')<CR>
    1              0.000011   xnoremap <silent> <buffer> [[ :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','b','v')<CR>
    1              0.000010   xnoremap <silent> <buffer> ]] :<C-U>call <SID>searchsyn('\<\%(class\<Bar>module\)\>','rubyModule\<Bar>rubyClass','','v')<CR>
    1              0.000009   xnoremap <silent> <buffer> [] :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','b','v')<CR>
    1              0.000009   xnoremap <silent> <buffer> ][ :<C-U>call <SID>searchsyn('\<end\>','rubyModule\<Bar>rubyClass','','v')<CR>
                            
    1              0.000006   let b:undo_ftplugin = b:undo_ftplugin
                                    \."| sil! exe 'unmap <buffer> [[' | sil! exe 'unmap <buffer> ]]' | sil! exe 'unmap <buffer> []' | sil! exe 'unmap <buffer> ]['"
                                    \."| sil! exe 'unmap <buffer> [m' | sil! exe 'unmap <buffer> ]m' | sil! exe 'unmap <buffer> [M' | sil! exe 'unmap <buffer> ]M'"
                            
    1              0.000014   if maparg('im','x') == '' && maparg('im','o') == '' && maparg('am','x') == '' && maparg('am','o') == ''
    1              0.000007     onoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    1              0.000006     onoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    1              0.000005     xnoremap <silent> <buffer> im :<C-U>call <SID>wrap_i('[m',']M')<CR>
    1              0.000006     xnoremap <silent> <buffer> am :<C-U>call <SID>wrap_a('[m',']M')<CR>
    1              0.000005     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> im' | sil! exe 'ounmap <buffer> am'"
                                      \."| sil! exe 'xunmap <buffer> im' | sil! exe 'xunmap <buffer> am'"
    1              0.000001   endif
                            
    1              0.000014   if maparg('iM','x') == '' && maparg('iM','o') == '' && maparg('aM','x') == '' && maparg('aM','o') == ''
    1              0.000005     onoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    1              0.000006     onoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    1              0.000006     xnoremap <silent> <buffer> iM :<C-U>call <SID>wrap_i('[[','][')<CR>
    1              0.000006     xnoremap <silent> <buffer> aM :<C-U>call <SID>wrap_a('[[','][')<CR>
    1              0.000005     let b:undo_ftplugin = b:undo_ftplugin
                                      \."| sil! exe 'ounmap <buffer> iM' | sil! exe 'ounmap <buffer> aM'"
                                      \."| sil! exe 'xunmap <buffer> iM' | sil! exe 'xunmap <buffer> aM'"
    1              0.000000   endif
                            
    1   0.000043   0.000013   call s:map('c', '', '<C-R><C-W> <Plug><cword>')
    1   0.000029   0.000005   call s:map('c', '', '<C-R><C-F> <Plug><cfile>')
                            
    1              0.000008   cmap <buffer><script><expr> <SID>tagzv &foldopen =~# 'tag' ? '<Bar>norm! zv' : ''
    1   0.000030   0.000004   call s:map('n', '<silent>', '<C-]>       <SID>:exe  v:count1."tag <Plug><cword>"<SID>tagzv<CR>')
    1   0.000029   0.000004   call s:map('n', '<silent>', 'g<C-]>      <SID>:exe         "tjump <Plug><cword>"<SID>tagzv<CR>')
    1   0.000027   0.000004   call s:map('n', '<silent>', 'g]          <SID>:exe       "tselect <Plug><cword>"<SID>tagzv<CR>')
    1   0.000027   0.000004   call s:map('n', '<silent>', '<C-W>]      <SID>:exe v:count1."stag <Plug><cword>"<SID>tagzv<CR>')
    1   0.000027   0.000003   call s:map('n', '<silent>', '<C-W><C-]>  <SID>:exe v:count1."stag <Plug><cword>"<SID>tagzv<CR>')
    1   0.000034   0.000003   call s:map('n', '<silent>', '<C-W>g<C-]> <SID>:exe        "stjump <Plug><cword>"<SID>tagzv<CR>')
    1   0.000028   0.000003   call s:map('n', '<silent>', '<C-W>g]     <SID>:exe      "stselect <Plug><cword>"<SID>tagzv<CR>')
    1   0.000028   0.000004   call s:map('n', '<silent>', '<C-W>}      <SID>:exe v:count1."ptag <Plug><cword>"<CR>')
    1   0.000026   0.000002   call s:map('n', '<silent>', '<C-W>g}     <SID>:exe        "ptjump <Plug><cword>"<CR>')
                            
    1   0.000024   0.000002   call s:map('n', '<silent>', 'gf           <SID>c:find <Plug><cfile><CR>')
    1   0.000027   0.000004   call s:map('n', '<silent>', '<C-W>f      <SID>c:sfind <Plug><cfile><CR>')
    1   0.000025   0.000004   call s:map('n', '<silent>', '<C-W><C-F>  <SID>c:sfind <Plug><cfile><CR>')
    1   0.000025   0.000002   call s:map('n', '<silent>', '<C-W>gf   <SID>c:tabfind <Plug><cfile><CR>')
    1              0.000001 endif
                            
    1              0.000007 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save
                            
    1              0.000003 if exists("g:did_ruby_ftplugin_functions")
    1              0.000001   finish
                            endif
                            let g:did_ruby_ftplugin_functions = 1
                            
                            function! RubyBalloonexpr() abort
                              if !exists('s:ri_found')
                                let s:ri_found = executable('ri')
                              endif
                              if s:ri_found
                                let line = getline(v:beval_lnum)
                                let b = matchstr(strpart(line,0,v:beval_col),'\%(\w\|[:.]\)*$')
                                let a = substitute(matchstr(strpart(line,v:beval_col),'^\w*\%([?!]\|\s*=\)\?'),'\s\+','','g')
                                let str = b.a
                                let before = strpart(line,0,v:beval_col-strlen(b))
                                let after  = strpart(line,v:beval_col+strlen(a))
                                if str =~ '^\.'
                                  let str = substitute(str,'^\.','#','g')
                                  if before =~ '\]\s*$'
                                    let str = 'Array'.str
                                  elseif before =~ '}\s*$'
                                    " False positives from blocks here
                                    let str = 'Hash'.str
                                  elseif before =~ "[\"'`]\\s*$" || before =~ '\$\d\+\s*$'
                                    let str = 'String'.str
                                  elseif before =~ '\$\d\+\.\d\+\s*$'
                                    let str = 'Float'.str
                                  elseif before =~ '\$\d\+\s*$'
                                    let str = 'Integer'.str
                                  elseif before =~ '/\s*$'
                                    let str = 'Regexp'.str
                                  else
                                    let str = substitute(str,'^#','.','')
                                  endif
                                endif
                                let str = substitute(str,'.*\.\s*to_f\s*\.\s*','Float#','')
                                let str = substitute(str,'.*\.\s*to_i\%(nt\)\=\s*\.\s*','Integer#','')
                                let str = substitute(str,'.*\.\s*to_s\%(tr\)\=\s*\.\s*','String#','')
                                let str = substitute(str,'.*\.\s*to_sym\s*\.\s*','Symbol#','')
                                let str = substitute(str,'.*\.\s*to_a\%(ry\)\=\s*\.\s*','Array#','')
                                let str = substitute(str,'.*\.\s*to_proc\s*\.\s*','Proc#','')
                                if str !~ '^\w'
                                  return ''
                                endif
                                silent! let res = substitute(system("ri -f rdoc -T \"".str.'"'),'\n$','','')
                                if res =~ '^Nothing known about' || res =~ '^Bad argument:' || res =~ '^More than one method'
                                  return ''
                                endif
                                return res
                              else
                                return ""
                              endif
                            endfunction
                            
                            function! s:searchsyn(pattern, syn, flags, mode) abort
                              let cnt = v:count1
                              norm! m'
                              if a:mode ==# 'v'
                                norm! gv
                              endif
                              let i = 0
                              while i < cnt
                                let i = i + 1
                                let line = line('.')
                                let col  = col('.')
                                let pos = search(a:pattern,'W'.a:flags)
                                while pos != 0 && s:synname() !~# a:syn
                                  let pos = search(a:pattern,'W'.a:flags)
                                endwhile
                                if pos == 0
                                  call cursor(line,col)
                                  return
                                endif
                              endwhile
                            endfunction
                            
                            function! s:synname() abort
                              return synIDattr(synID(line('.'),col('.'),0),'name')
                            endfunction
                            
                            function! s:wrap_i(back,forward) abort
                              execute 'norm k'.a:forward
                              let line = line('.')
                              execute 'norm '.a:back
                              if line('.') == line - 1
                                return s:wrap_a(a:back,a:forward)
                              endif
                              execute 'norm jV'.a:forward.'k'
                            endfunction
                            
                            function! s:wrap_a(back,forward) abort
                              execute 'norm '.a:forward
                              if line('.') < line('$') && getline(line('.')+1) ==# ''
                                let after = 1
                              endif
                              execute 'norm '.a:back
                              while getline(line('.')-1) =~# '^\s*#' && line('.')
                                -
                              endwhile
                              if exists('after')
                                execute 'norm V'.a:forward.'j'
                              elseif line('.') > 1 && getline(line('.')-1) =~# '^\s*$'
                                execute 'norm kV'.a:forward
                              else
                                execute 'norm V'.a:forward
                              endif
                            endfunction
                            
                            function! RubyCursorIdentifier() abort
                              let asciicode    = '\%(\w\|[]})\"'."'".']\)\@<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)'
                              let number       = '\%(\%(\w\|[]})\"'."'".']\s*\)\@<!-\)\=\%(\<[[:digit:]_]\+\%(\.[[:digit:]_]\+\)\=\%([Ee][[:digit:]_]\+\)\=\>\|\<0[xXbBoOdD][[:xdigit:]_]\+\>\)\|'.asciicode
                              let operator     = '\%(\[\]\|<<\|<=>\|[!<>]=\=\|===\=\|[!=]\~\|>>\|\*\*\|\.\.\.\=\|=>\|[~^&|*/%+-]\)'
                              let method       = '\%(\.[_a-zA-Z]\w*\s*=>\@!\|\<[_a-zA-Z]\w*\>[?!]\=\)'
                              let global       = '$\%([!$&"'."'".'*+,./:;<=>?@\`~]\|-\=\w\+\>\)'
                              let symbolizable = '\%(\%(@@\=\)\w\+\>\|'.global.'\|'.method.'\|'.operator.'\)'
                              let pattern      = '\C\s*\%('.number.'\|\%(:\@<!:\)\='.symbolizable.'\)'
                              let [lnum, col]  = searchpos(pattern,'bcn',line('.'))
                              let raw          = matchstr(getline('.')[col-1 : ],pattern)
                              let stripped     = substitute(substitute(raw,'\s\+=$','=',''),'^\s*[:.]\=','','')
                              return stripped == '' ? expand("<cword>") : stripped
                            endfunction
                            
                            function! RubyCursorFile() abort
                              let isfname = &isfname
                              try
                                set isfname+=:
                                let cfile = expand('<cfile>')
                              finally
                                let isfname = &isfname
                              endtry
                              let pre = matchstr(strpart(getline('.'), 0, col('.')-1), '.*\f\@<!')
                              let post = matchstr(strpart(getline('.'), col('.')), '\f\@!.*')
                              let ext = getline('.') =~# '^\s*\%(require\%(_relative\)\=\|autoload\)\>' && cfile !~# '\.rb$' ? '.rb' : ''
                              if s:synname() ==# 'rubyConstant'
                                let cfile = substitute(cfile,'\.\w\+[?!=]\=$','','')
                                let cfile = substitute(cfile,'::','/','g')
                                let cfile = substitute(cfile,'\(\u\+\)\(\u\l\)','\1_\2', 'g')
                                let cfile = substitute(cfile,'\(\l\|\d\)\(\u\)','\1_\2', 'g')
                                return tolower(cfile) . '.rb'
                              elseif getline('.') =~# '^\s*require_relative\s*\(["'']\).*\1\s*$'
                                let cfile = expand('%:p:h') . '/' . matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1') . ext
                              elseif getline('.') =~# '^\s*\%(require[( ]\|load[( ]\|autoload[( ]:\w\+,\)\s*\%(::\)\=File\.expand_path(\(["'']\)\.\./.*\1,\s*__FILE__)\s*$'
                                let target = matchstr(getline('.'),'\(["'']\)\.\.\zs/.\{-\}\ze\1')
                                let cfile = expand('%:p:h') . target . ext
                              elseif getline('.') =~# '^\s*\%(require \|load \|autoload :\w\+,\)\s*\(["'']\).*\1\s*$'
                                let cfile = matchstr(getline('.'),'\(["'']\)\zs.\{-\}\ze\1') . ext
                              elseif pre.post =~# '\<File.expand_path[( ].*[''"]\{2\}, *__FILE__\>' && cfile =~# '^\.\.'
                                let cfile = expand('%:p:h') . strpart(cfile, 2)
                              else
                                return substitute(cfile, '\C\v^(.*):(\d+)%(:in)=$', '+\2 \1', '')
                              endif
                              let cwdpat = '^\M' . substitute(getcwd(), '[\/]', '\\[\\/]', 'g').'\ze\[\/]'
                              let cfile = substitute(cfile, cwdpat, '.', '')
                              if fnameescape(cfile) !=# cfile
                                return '+ '.fnameescape(cfile)
                              else
                                return cfile
                              endif
                            endfunction
                            
                            "
                            " Instructions for enabling "matchit" support:
                            "
                            " 1. Look for the latest "matchit" plugin at
                            "
                            "         http://www.vim.org/scripts/script.php?script_id=39
                            "
                            "    It is also packaged with Vim, in the $VIMRUNTIME/macros directory.
                            "
                            " 2. Copy "matchit.txt" into a "doc" directory (e.g. $HOME/.vim/doc).
                            "
                            " 3. Copy "matchit.vim" into a "plugin" directory (e.g. $HOME/.vim/plugin).
                            "
                            " 4. Ensure this file (ftplugin/ruby.vim) is installed.
                            "
                            " 5. Ensure you have this line in your $HOME/.vimrc:
                            "         filetype plugin on
                            "
                            " 6. Restart Vim and create the matchit documentation:
                            "
                            "         :helptags ~/.vim/doc
                            "
                            "    Now you can do ":help matchit", and you should be able to use "%" on Ruby
                            "    keywords.  Try ":echo b:match_words" to be sure.
                            "
                            " Thanks to Mark J. Reed for the instructions.  See ":help vimrc" for the
                            " locations of plugin directories, etc., as there are several options, and it
                            " differs on Windows.  Email gsinclair@soyabean.com.au if you need help.
                            "
                            
                            " vim: nowrap sw=2 sts=2 ts=8:

SCRIPT  /usr/share/vim/vim81/indent/ruby.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Ruby
                            " Maintainer:		Nikolai Weibull <now at bitwi.se>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    1              0.000002 if exists("b:did_indent")
                              finish
                            endif
    1              0.000001 let b:did_indent = 1
                            
    1              0.000002 if !exists('g:ruby_indent_access_modifier_style')
                              " Possible values: "normal", "indent", "outdent"
                              let g:ruby_indent_access_modifier_style = 'normal'
                            endif
                            
    1              0.000003 if !exists('g:ruby_indent_block_style')
                              " Possible values: "expression", "do"
                              let g:ruby_indent_block_style = 'expression'
                            endif
                            
    1              0.000006 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    1              0.000002 setlocal indentexpr=GetRubyIndent(v:lnum)
    1              0.000003 setlocal indentkeys=0{,0},0),0],!^F,o,O,e,:,.
    1              0.000002 setlocal indentkeys+==end,=else,=elsif,=when,=ensure,=rescue,==begin,==end
    1              0.000002 setlocal indentkeys+==private,=protected,=public
                            
                            " Only define the function once.
    1              0.000002 if exists("*GetRubyIndent")
    1              0.000001   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
                            " Regex of syntax group names that are or delimit strings/symbols or are comments.
                            let s:syng_strcom = '\<ruby\%(Regexp\|RegexpDelimiter\|RegexpEscape' .
                                  \ '\|Symbol\|String\|StringDelimiter\|StringEscape\|ASCIICode' .
                                  \ '\|Interpolation\|InterpolationDelimiter\|NoInterpolation\|Comment\|Documentation\)\>'
                            
                            " Regex of syntax group names that are strings.
                            let s:syng_string =
                                  \ '\<ruby\%(String\|Interpolation\|NoInterpolation\|StringEscape\)\>'
                            
                            " Regex of syntax group names that are strings or documentation.
                            let s:syng_stringdoc =
                                  \'\<ruby\%(String\|Interpolation\|NoInterpolation\|StringEscape\|Documentation\)\>'
                            
                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr =
                                  \ "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"
                            
                            " Regex used for words that, at the start of a line, add a level of indent.
                            let s:ruby_indent_keywords =
                                  \ '^\s*\zs\<\%(module\|class\|if\|for' .
                                  \   '\|while\|until\|else\|elsif\|case\|when\|unless\|begin\|ensure\|rescue' .
                                  \   '\|\%(public\|protected\|private\)\=\s*def\):\@!\>' .
                                  \ '\|\%([=,*/%+-]\|<<\|>>\|:\s\)\s*\zs' .
                                  \    '\<\%(if\|for\|while\|until\|case\|unless\|begin\):\@!\>'
                            
                            " Regex used for words that, at the start of a line, remove a level of indent.
                            let s:ruby_deindent_keywords =
                                  \ '^\s*\zs\<\%(ensure\|else\|rescue\|elsif\|when\|end\):\@!\>'
                            
                            " Regex that defines the start-match for the 'end' keyword.
                            "let s:end_start_regex = '\%(^\|[^.]\)\<\%(module\|class\|def\|if\|for\|while\|until\|case\|unless\|begin\|do\)\>'
                            " TODO: the do here should be restricted somewhat (only at end of line)?
                            let s:end_start_regex =
                                  \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
                                  \ '\<\%(module\|class\|if\|for\|while\|until\|case\|unless\|begin' .
                                  \   '\|\%(public\|protected\|private\)\=\s*def\):\@!\>' .
                                  \ '\|\%(^\|[^.:@$]\)\@<=\<do:\@!\>'
                            
                            " Regex that defines the middle-match for the 'end' keyword.
                            let s:end_middle_regex = '\<\%(ensure\|else\|\%(\%(^\|;\)\s*\)\@<=\<rescue:\@!\>\|when\|elsif\):\@!\>'
                            
                            " Regex that defines the end-match for the 'end' keyword.
                            let s:end_end_regex = '\%(^\|[^.:@$]\)\@<=\<end:\@!\>'
                            
                            " Expression used for searchpair() call for finding match for 'end' keyword.
                            let s:end_skip_expr = s:skip_expr .
                                  \ ' || (expand("<cword>") == "do"' .
                                  \ ' && getline(".") =~ "^\\s*\\<\\(while\\|until\\|for\\):\\@!\\>")'
                            
                            " Regex that defines continuation lines, not including (, {, or [.
                            let s:non_bracket_continuation_regex =
                                  \ '\%([\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|:\@<![^[:alnum:]:][|&?]\|||\|&&\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines continuation lines.
                            let s:continuation_regex =
                                  \ '\%(%\@<![({[\\.,:*/%+]\|\<and\|\<or\|\%(<%\)\@<![=-]\|:\@<![^[:alnum:]:][|&?]\|||\|&&\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines continuable keywords
                            let s:continuable_regex =
                                  \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
                                  \ '\<\%(if\|for\|while\|until\|unless\):\@!\>'
                            
                            " Regex that defines bracket continuations
                            let s:bracket_continuation_regex = '%\@<!\%([({[]\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines dot continuations
                            let s:dot_continuation_regex = '%\@<!\.\s*\%(#.*\)\=$'
                            
                            " Regex that defines backslash continuations
                            let s:backslash_continuation_regex = '%\@<!\\\s*$'
                            
                            " Regex that defines end of bracket continuation followed by another continuation
                            let s:bracket_switch_continuation_regex = '^\([^(]\+\zs).\+\)\+'.s:continuation_regex
                            
                            " Regex that defines the first part of a splat pattern
                            let s:splat_regex = '[[,(]\s*\*\s*\%(#.*\)\=$'
                            
                            " Regex that describes all indent access modifiers
                            let s:access_modifier_regex = '\C^\s*\%(public\|protected\|private\)\s*\%(#.*\)\=$'
                            
                            " Regex that describes the indent access modifiers (excludes public)
                            let s:indent_access_modifier_regex = '\C^\s*\%(protected\|private\)\s*\%(#.*\)\=$'
                            
                            " Regex that defines blocks.
                            "
                            " Note that there's a slight problem with this regex and s:continuation_regex.
                            " Code like this will be matched by both:
                            "
                            "   method_call do |(a, b)|
                            "
                            " The reason is that the pipe matches a hanging "|" operator.
                            "
                            let s:block_regex =
                                  \ '\%(\<do:\@!\>\|%\@<!{\)\s*\%(|[^|]*|\)\=\s*\%(#.*\)\=$'
                            
                            let s:block_continuation_regex = '^\s*[^])}\t ].*'.s:block_regex
                            
                            " Regex that describes a leading operator (only a method call's dot for now)
                            let s:leading_operator_regex = '^\s*[.]'
                            
                            " 2. Auxiliary Functions {{{1
                            " ======================
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
                            function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
                            function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string or documentation.
                            function s:IsInStringOrDocumentation(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_stringdoc
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string delimiter
                            function s:IsInStringDelimiter(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') == 'rubyStringDelimiter'
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
                            function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '^=begin'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '^=end'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1)
                                      \ && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
                            function s:GetMSL(lnum)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let msl_body = getline(msl)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                            
                                if !s:Match(msl, s:backslash_continuation_regex) &&
                                      \ s:Match(lnum, s:backslash_continuation_regex)
                                  " If the current line doesn't end in a backslash, but the previous one
                                  " does, look for that line's msl
                                  "
                                  " Example:
                                  "   foo = "bar" \
                                  "     "baz"
                                  "
                                  let msl = lnum
                                elseif s:Match(msl, s:leading_operator_regex)
                                  " If the current line starts with a leading operator, keep its indent
                                  " and keep looking for an MSL.
                                  let msl = lnum
                                elseif s:Match(lnum, s:splat_regex)
                                  " If the above line looks like the "*" of a splat, use the current one's
                                  " indentation.
                                  "
                                  " Example:
                                  "   Hash[*
                                  "     method_call do
                                  "       something
                                  "
                                  return msl
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
                                      \ s:Match(msl, s:non_bracket_continuation_regex)
                                  " If the current line is a non-bracket continuation and so is the
                                  " previous one, keep its indent and continue looking for an MSL.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two,
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:dot_continuation_regex) &&
                                      \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a dot, keep going to see if the previous line is the
                                  " start of another continuation.
                                  "
                                  " Example:
                                  "   parent.
                                  "     method_call {
                                  "     three
                                  "
                                  let msl = lnum
                                elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
                                      \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a non-bracket one, respect the previous' indentation,
                                  " and stop here.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two {
                                  "     three
                                  "
                                  return lnum
                                elseif s:Match(lnum, s:bracket_continuation_regex) &&
                                      \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If both lines are bracket continuations (the current may also be a
                                  " block-starter), use the current one's and stop here
                                  "
                                  " Example:
                                  "   method_call(
                                  "     other_method_call(
                                  "       foo
                                  return msl
                                elseif s:Match(lnum, s:block_regex) &&
                                      \ !s:Match(msl, s:continuation_regex) &&
                                      \ !s:Match(msl, s:block_continuation_regex)
                                  " If the previous line is a block-starter and the current one is
                                  " mostly ordinary, use the current one as the MSL.
                                  "
                                  " Example:
                                  "   method_call do
                                  "     something
                                  "     something_else
                                  return msl
                                else
                                  let col = match(line, s:continuation_regex) + 1
                                  if (col > 0 && !s:IsInStringOrComment(lnum, col))
                                        \ || s:IsInString(lnum, strlen(line))
                                    let msl = lnum
                                  else
                                    break
                                  endif
                                endif
                            
                                let msl_body = getline(msl)
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
                            function s:ExtraBrackets(lnum)
                              let opening = {'parentheses': [], 'braces': [], 'brackets': []}
                              let closing = {'parentheses': [], 'braces': [], 'brackets': []}
                            
                              let line = getline(a:lnum)
                              let pos  = match(line, '[][(){}]', 0)
                            
                              " Save any encountered opening brackets, and remove them once a matching
                              " closing one has been found. If a closing bracket shows up that doesn't
                              " close anything, save it for later.
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  if line[pos] == '('
                                    call add(opening.parentheses, {'type': '(', 'pos': pos})
                                  elseif line[pos] == ')'
                                    if empty(opening.parentheses)
                                      call add(closing.parentheses, {'type': ')', 'pos': pos})
                                    else
                                      let opening.parentheses = opening.parentheses[0:-2]
                                    endif
                                  elseif line[pos] == '{'
                                    call add(opening.braces, {'type': '{', 'pos': pos})
                                  elseif line[pos] == '}'
                                    if empty(opening.braces)
                                      call add(closing.braces, {'type': '}', 'pos': pos})
                                    else
                                      let opening.braces = opening.braces[0:-2]
                                    endif
                                  elseif line[pos] == '['
                                    call add(opening.brackets, {'type': '[', 'pos': pos})
                                  elseif line[pos] == ']'
                                    if empty(opening.brackets)
                                      call add(closing.brackets, {'type': ']', 'pos': pos})
                                    else
                                      let opening.brackets = opening.brackets[0:-2]
                                    endif
                                  endif
                                endif
                            
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                            
                              " Find the rightmost brackets, since they're the ones that are important in
                              " both opening and closing cases
                              let rightmost_opening = {'type': '(', 'pos': -1}
                              let rightmost_closing = {'type': ')', 'pos': -1}
                            
                              for opening in opening.parentheses + opening.braces + opening.brackets
                                if opening.pos > rightmost_opening.pos
                                  let rightmost_opening = opening
                                endif
                              endfor
                            
                              for closing in closing.parentheses + closing.braces + closing.brackets
                                if closing.pos > rightmost_closing.pos
                                  let rightmost_closing = closing
                                endif
                              endfor
                            
                              return [rightmost_opening, rightmost_closing]
                            endfunction
                            
                            function s:Match(lnum, regex)
                              let line   = getline(a:lnum)
                              let offset = match(line, '\C'.a:regex)
                              let col    = offset + 1
                            
                              while offset > -1 && s:IsInStringOrComment(a:lnum, col)
                                let offset = match(line, '\C'.a:regex, offset + 1)
                                let col = offset + 1
                              endwhile
                            
                              if offset > -1
                                return col
                              else
                                return 0
                              endif
                            endfunction
                            
                            " Locates the containing class/module's definition line, ignoring nested classes
                            " along the way.
                            "
                            function! s:FindContainingClass()
                              let saved_position = getpos('.')
                            
                              while searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
                                    \ s:end_skip_expr) > 0
                                if expand('<cword>') =~# '\<class\|module\>'
                                  let found_lnum = line('.')
                                  call setpos('.', saved_position)
                                  return found_lnum
                                endif
                              endwhile
                            
                              call setpos('.', saved_position)
                              return 0
                            endfunction
                            
                            " 3. GetRubyIndent Function {{{1
                            " =========================
                            
                            function GetRubyIndent(...)
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " The value of a single shift-width
                              let sw = shiftwidth()
                            
                              " For the current line, use the first argument if given, else v:lnum
                              let clnum = a:0 ? a:1 : v:lnum
                            
                              " Set up variables for restoring position in file.  Could use clnum here.
                              let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              " Get the current line.
                              let line = getline(clnum)
                              let ind = -1
                            
                              " If this line is an access modifier keyword, align according to the closest
                              " class declaration.
                              if g:ruby_indent_access_modifier_style == 'indent'
                                if s:Match(clnum, s:access_modifier_regex)
                                  let class_line = s:FindContainingClass()
                                  if class_line > 0
                                    return indent(class_line) + sw
                                  endif
                                endif
                              elseif g:ruby_indent_access_modifier_style == 'outdent'
                                if s:Match(clnum, s:access_modifier_regex)
                                  let class_line = s:FindContainingClass()
                                  if class_line > 0
                                    return indent(class_line)
                                  endif
                                endif
                              endif
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[]})]')
                              if col > 0 && !s:IsInStringOrComment(clnum, col)
                                call cursor(clnum, col)
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.') - 1
                                  elseif g:ruby_indent_block_style == 'do'
                                    let ind = indent(line('.'))
                                  else " g:ruby_indent_block_style == 'expression'
                                    let ind = indent(s:GetMSL(line('.')))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If we have a =begin or =end set indent to first column.
                              if match(line, '^\s*\%(=begin\|=end\)$') != -1
                                return 0
                              endif
                            
                              " If we have a deindenting keyword, find its match and indent to its level.
                              " TODO: this is messy
                              if s:Match(clnum, s:ruby_deindent_keywords)
                                call cursor(clnum, 1)
                                if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
                                      \ s:end_skip_expr) > 0
                                  let msl  = s:GetMSL(line('.'))
                                  let line = getline(line('.'))
                            
                                  if strpart(line, 0, col('.') - 1) =~ '=\s*$' &&
                                        \ strpart(line, col('.') - 1, 2) !~ 'do'
                                    " assignment to case/begin/etc, on the same line, hanging indent
                                    let ind = virtcol('.') - 1
                                  elseif g:ruby_indent_block_style == 'do'
                                    " align to line of the "do", not to the MSL
                                    let ind = indent(line('.'))
                                  elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the MSL, align to the starting line,
                                    " not to the MSL
                                    let ind = indent(line('.'))
                                  else
                                    " align to the MSL
                                    let ind = indent(msl)
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If we are in a multi-line string or line-comment, don't do anything to it.
                              if s:IsInStringOrDocumentation(clnum, matchend(line, '^\s*') + 1)
                                return indent('.')
                              endif
                            
                              " If we are at the closing delimiter of a "<<" heredoc-style string, set the
                              " indent to 0.
                              if line =~ '^\k\+\s*$'
                                    \ && s:IsInStringDelimiter(clnum, 1)
                                    \ && search('\V<<'.line, 'nbW') > 0
                                return 0
                              endif
                            
                              " If the current line starts with a leading operator, add a level of indent.
                              if s:Match(clnum, s:leading_operator_regex)
                                return indent(s:GetMSL(clnum)) + sw
                              endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(clnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevnonblank(clnum - 1)
                                return indent(prevnonblank(clnum))
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for the previous line.
                              let line = getline(lnum)
                              let ind = indent(lnum)
                            
                              if g:ruby_indent_access_modifier_style == 'indent'
                                " If the previous line was a private/protected keyword, add a
                                " level of indent.
                                if s:Match(lnum, s:indent_access_modifier_regex)
                                  return indent(lnum) + sw
                                endif
                              elseif g:ruby_indent_access_modifier_style == 'outdent'
                                " If the previous line was a private/protected/public keyword, add
                                " a level of indent, since the keyword has been out-dented.
                                if s:Match(lnum, s:access_modifier_regex)
                                  return indent(lnum) + sw
                                endif
                              endif
                            
                              if s:Match(lnum, s:continuable_regex) && s:Match(lnum, s:continuation_regex)
                                return indent(s:GetMSL(lnum)) + sw + sw
                              endif
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                let msl = s:GetMSL(lnum)
                            
                                if g:ruby_indent_block_style == 'do'
                                  " don't align to the msl, align to the "do"
                                  let ind = indent(lnum) + sw
                                elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                  " in the case of assignment to the msl, align to the starting line,
                                  " not to the msl
                                  let ind = indent(lnum) + sw
                                else
                                  let ind = indent(msl) + sw
                                endif
                                return ind
                              endif
                            
                              " If the previous line started with a leading operator, use its MSL's level
                              " of indent
                              if s:Match(lnum, s:leading_operator_regex)
                                return indent(s:GetMSL(lnum))
                              endif
                            
                              " If the previous line ended with the "*" of a splat, add a level of indent
                              if line =~ s:splat_regex
                                return indent(lnum) + sw
                              endif
                            
                              " If the previous line contained unclosed opening brackets and we are still
                              " in them, find the rightmost one and add indent depending on the bracket
                              " type.
                              "
                              " If it contained hanging closing brackets, find the rightmost one, find its
                              " match and indent according to that.
                              if line =~ '[[({]' || line =~ '[])}]\s*\%(#.*\)\=$'
                                let [opening, closing] = s:ExtraBrackets(lnum)
                            
                                if opening.pos != -1
                                  if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                    if col('.') + 1 == col('$')
                                      return ind + sw
                                    else
                                      return virtcol('.')
                                    endif
                                  else
                                    let nonspace = matchend(line, '\S', opening.pos + 1) - 1
                                    return nonspace > 0 ? nonspace : ind + sw
                                  endif
                                elseif closing.pos != -1
                                  call cursor(lnum, closing.pos + 1)
                                  normal! %
                            
                                  if s:Match(line('.'), s:ruby_indent_keywords)
                                    return indent('.') + sw
                                  else
                                    return indent(s:GetMSL(line('.')))
                                  endif
                                else
                                  call cursor(clnum, vcol)
                                end
                              endif
                            
                              " If the previous line ended with an "end", match that "end"s beginning's
                              " indent.
                              let col = s:Match(lnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
                              if col > 0
                                call cursor(lnum, col)
                                if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW',
                                      \ s:end_skip_expr) > 0
                                  let n = line('.')
                                  let ind = indent('.')
                                  let msl = s:GetMSL(n)
                                  if msl != n
                                    let ind = indent(msl)
                                  end
                                  return ind
                                endif
                              end
                            
                              let col = s:Match(lnum, s:ruby_indent_keywords)
                              if col > 0
                                call cursor(lnum, col)
                                let ind = virtcol('.') - 1 + sw
                                " TODO: make this better (we need to count them) (or, if a searchpair
                                " fails, we know that something is lacking an end and thus we indent a
                                " level
                                if s:Match(lnum, s:end_end_regex)
                                  let ind = indent('.')
                                endif
                                return ind
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = lnum
                              let lnum = s:GetMSL(lnum)
                            
                              " If the previous line wasn't a MSL.
                              if p_lnum != lnum
                                " If previous line ends bracket and begins non-bracket continuation decrease indent by 1.
                                if s:Match(p_lnum, s:bracket_switch_continuation_regex)
                                  return ind - 1
                                " If previous line is a continuation return its indent.
                                " TODO: the || s:IsInString() thing worries me a bit.
                                elseif s:Match(p_lnum, s:non_bracket_continuation_regex) || s:IsInString(p_lnum,strlen(line))
                                  return ind
                                endif
                              endif
                            
                              " Set up more variables, now that we know we wasn't continuation bound.
                              let line = getline(lnum)
                              let msl_ind = indent(lnum)
                            
                              " If the MSL line had an indenting keyword in it, add a level of indent.
                              " TODO: this does not take into account contrived things such as
                              " module Foo; class Bar; end
                              if s:Match(lnum, s:ruby_indent_keywords)
                                let ind = msl_ind + sw
                                if s:Match(lnum, s:end_end_regex)
                                  let ind = ind - sw
                                endif
                                return ind
                              endif
                            
                              " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
                              " closing bracket, indent one extra level.
                              if s:Match(lnum, s:non_bracket_continuation_regex) && !s:Match(lnum, '^\s*\([\])}]\|end\)')
                                if lnum == p_lnum
                                  let ind = msl_ind + sw
                                else
                                  let ind = msl_ind
                                endif
                                return ind
                              endif
                            
                              " }}}2
                            
                              return ind
                            endfunction
                            
                            " }}}1
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 et:

SCRIPT  /usr/share/vim/vim81/syntax/ruby.vim
Sourced 1 time
Total time:   0.005108
 Self time:   0.005062

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		Ruby
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Previous Maintainer:	Mirko Nasato
                            " Thanks to perl.vim authors, and to Reimer Behrends. :-) (MN)
                            " ----------------------------------------------------------------------------
                            
                            " Prelude {{{1
    1              0.000003 if exists("b:current_syntax")
                              finish
                            endif
                            
                            " this file uses line continuations
    1              0.000005 let s:cpo_sav = &cpo
    1              0.000007 set cpo&vim
                            
                            " Folding Config {{{1
    1              0.000004 if has("folding") && exists("ruby_fold")
                              setlocal foldmethod=syntax
                            endif
                            
    1              0.000012 let s:foldable_groups = split(
                                  \	  get(
                                  \	    b:,
                                  \	    'ruby_foldable_groups',
                                  \	    get(g:, 'ruby_foldable_groups', 'ALL')
                                  \	  )
                                  \	)
                            
    1              0.000003 function! s:foldable(...) abort
                              if index(s:foldable_groups, 'ALL') > -1
                                return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction " }}}
                            
    1              0.000039 syn cluster rubyNotTop contains=@rubyExtendedStringSpecial,@rubyRegexpSpecial,@rubyDeclaration,rubyConditional,rubyExceptional,rubyMethodExceptional,rubyTodo
                            
                            " Whitespace Errors {{{1
    1              0.000003 if exists("ruby_space_errors")
                              if !exists("ruby_no_trail_space_error")
                                syn match rubySpaceError display excludenl "\s\+$"
                              endif
                              if !exists("ruby_no_tab_space_error")
                                syn match rubySpaceError display " \+\t"me=e-1
                              endif
                            endif
                            
                            " Operators {{{1
    1              0.000002 if exists("ruby_operators")
                              syn match  rubyOperator "[~!^|*/%+-]\|&\.\@!\|\%(class\s*\)\@<!<<\|<=>\|<=\|\%(<\|\<class\s\+\u\w*\s*\)\@<!<[^<]\@=\|===\|==\|=\~\|>>\|>=\|=\@1<!>\|\*\*\|\.\.\.\|\.\.\|::"
                              syn match  rubyOperator "->\|-=\|/=\|\*\*=\|\*=\|&&=\|&=\|&&\|||=\||=\|||\|%=\|+=\|!\~\|!="
                              syn region rubyBracketOperator matchgroup=rubyOperator start="\%(\w[?!]\=\|[]})]\)\@2<=\[\s*" end="\s*]" contains=ALLBUT,@rubyNotTop
                            endif
                            
                            " Expression Substitution and Backslash Notation {{{1
    1              0.000012 syn match rubyStringEscape "\\\\\|\\[abefnrstv]\|\\\o\{1,3}\|\\x\x\{1,2}"						    contained display
    1              0.000014 syn match rubyStringEscape "\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)" contained display
    1              0.000008 syn match rubyQuoteEscape  "\\[\\']"											    contained display
                            
    1              0.000016 syn region rubyInterpolation	      matchgroup=rubyInterpolationDelimiter start="#{" end="}" contained contains=ALLBUT,@rubyNotTop
    1              0.000050 syn match  rubyInterpolation	      "#\%(\$\|@@\=\)\w\+"    display contained contains=rubyInterpolationDelimiter,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable,rubyPredefinedVariable
    1              0.000009 syn match  rubyInterpolationDelimiter "#\ze\%(\$\|@@\=\)\w\+" display contained
    1              0.000031 syn match  rubyInterpolation	      "#\$\%(-\w\|\W\)"       display contained contains=rubyInterpolationDelimiter,rubyPredefinedVariable,rubyInvalidVariable
    1              0.000008 syn match  rubyInterpolationDelimiter "#\ze\$\%(-\w\|\W\)"    display contained
    1              0.000009 syn region rubyNoInterpolation	      start="\\#{" end="}"	      contained
    1              0.000008 syn match  rubyNoInterpolation	      "\\#{"		      display contained
    1              0.000007 syn match  rubyNoInterpolation	      "\\#\%(\$\|@@\=\)\w\+"  display contained
    1              0.000007 syn match  rubyNoInterpolation	      "\\#\$\W"		      display contained
                            
    1              0.000016 syn match rubyDelimiterEscape	"\\[(<{\[)>}\]]" transparent display contained contains=NONE
                            
    1              0.000015 syn region rubyNestedParentheses    start="("  skip="\\\\\|\\)"  matchgroup=rubyString end=")"	transparent contained
    1              0.000014 syn region rubyNestedCurlyBraces    start="{"  skip="\\\\\|\\}"  matchgroup=rubyString end="}"	transparent contained
    1              0.000013 syn region rubyNestedAngleBrackets  start="<"  skip="\\\\\|\\>"  matchgroup=rubyString end=">"	transparent contained
    1              0.000014 syn region rubyNestedSquareBrackets start="\[" skip="\\\\\|\\\]" matchgroup=rubyString end="\]"	transparent contained
                            
                            " Regular Expression Metacharacters {{{1
                            " These are mostly Oniguruma ready
    1              0.000016 syn region rubyRegexpComment	matchgroup=rubyRegexpSpecial   start="(?#"								  skip="\\)"  end=")"  contained
    1              0.000024 syn region rubyRegexpParens	matchgroup=rubyRegexpSpecial   start="(\(?:\|?<\=[=!]\|?>\|?<[a-z_]\w*>\|?[imx]*-[imx]*:\=\|\%(?#\)\@!\)" skip="\\)"  end=")"  contained transparent contains=@rubyRegexpSpecial
    1              0.000040 syn region rubyRegexpBrackets	matchgroup=rubyRegexpCharClass start="\[\^\="								  skip="\\\]" end="\]" contained transparent contains=rubyStringEscape,rubyRegexpEscape,rubyRegexpCharClass oneline
    1              0.000008 syn match  rubyRegexpCharClass	"\\[DdHhSsWw]"	       contained display
    1              0.000012 syn match  rubyRegexpCharClass	"\[:\^\=\%(alnum\|alpha\|ascii\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\):\]" contained
    1              0.000008 syn match  rubyRegexpEscape	"\\[].*?+^$|\\/(){}[]" contained
    1              0.000007 syn match  rubyRegexpQuantifier	"[*?+][?+]\="	       contained display
    1              0.000009 syn match  rubyRegexpQuantifier	"{\d\+\%(,\d*\)\=}?\=" contained display
    1              0.000009 syn match  rubyRegexpAnchor	"[$^]\|\\[ABbGZz]"     contained display
    1              0.000007 syn match  rubyRegexpDot	"\."		       contained display
    1              0.000007 syn match  rubyRegexpSpecial	"|"		       contained display
    1              0.000007 syn match  rubyRegexpSpecial	"\\[1-9]\d\=\d\@!"     contained display
    1              0.000010 syn match  rubyRegexpSpecial	"\\k<\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\=>" contained display
    1              0.000008 syn match  rubyRegexpSpecial	"\\k'\%([a-z_]\w*\|-\=\d\+\)\%([+-]\d\+\)\='" contained display
    1              0.000008 syn match  rubyRegexpSpecial	"\\g<\%([a-z_]\w*\|-\=\d\+\)>" contained display
    1              0.000007 syn match  rubyRegexpSpecial	"\\g'\%([a-z_]\w*\|-\=\d\+\)'" contained display
                            
    1              0.000028 syn cluster rubyStringSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape
    1              0.000034 syn cluster rubyExtendedStringSpecial contains=@rubyStringSpecial,rubyNestedParentheses,rubyNestedCurlyBraces,rubyNestedAngleBrackets,rubyNestedSquareBrackets
    1              0.000092 syn cluster rubyRegexpSpecial	      contains=rubyInterpolation,rubyNoInterpolation,rubyStringEscape,rubyRegexpSpecial,rubyRegexpEscape,rubyRegexpBrackets,rubyRegexpCharClass,rubyRegexpDot,rubyRegexpQuantifier,rubyRegexpAnchor,rubyRegexpParens,rubyRegexpComment
                            
                            " Numbers and ASCII Codes {{{1
    1              0.000016 syn match rubyASCIICode "\%(\w\|[]})\"'/]\)\@1<!\%(?\%(\\M-\\C-\|\\C-\\M-\|\\M-\\c\|\\c\\M-\|\\c\|\\C-\|\\M-\)\=\%(\\\o\{1,3}\|\\x\x\{1,2}\|\\\=\S\)\)"
    1              0.000012 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[xX]\x\+\%(_\x\+\)*r\=i\=\>"								display
    1              0.000012 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0[dD]\)\=\%(0\|[1-9]\d*\%(_\d\+\)*\)r\=i\=\>"						display
    1              0.000010 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[oO]\=\o\+\%(_\o\+\)*r\=i\=\>"								display
    1              0.000010 syn match rubyInteger	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<0[bB][01]\+\%(_[01]\+\)*r\=i\=\>"								display
    1              0.000010 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\.\d\+\%(_\d\+\)*r\=i\=\>"					display
    1              0.000012 syn match rubyFloat	"\%(\%(\w\|[]})\"']\s*\)\@<!-\)\=\<\%(0\|[1-9]\d*\%(_\d\+\)*\)\%(\.\d\+\%(_\d\+\)*\)\=\%([eE][-+]\=\d\+\%(_\d\+\)*\)r\=i\=\>"	display
                            
                            " Identifiers {{{1
    1              0.000018 syn match rubyLocalVariableOrMethod "\<[_[:lower:]][_[:alnum:]]*[?!=]\=" contains=NONE display transparent
    1              0.000016 syn match rubyBlockArgument	    "&[_[:lower:]][_[:alnum:]]"		 contains=NONE display transparent
                            
    1              0.000011 syn match  rubyConstant		"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)\@!"
    1              0.000010 syn match  rubyClassVariable	"@@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" display
    1              0.000027 syn match  rubyInstanceVariable "@\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"	display
    1              0.000011 syn match  rubyGlobalVariable	"$\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\|-.\)"
    1              0.000014 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\^\|\~@\|\~\|<<\|<=>\|<=\|<\|===\|[=!]=\|[=!]\~\|!@\|!\|>>\|>=\|>\||\|-@\|-\|/\|\[]=\|\[]\|\*\*\|\*\|&\|%\|+@\|+\|`\)"
    1              0.000010 syn match  rubySymbol		"[]})\"':]\@1<!:\$\%(-.\|[`~<=>_,;:!?/.'"@$*\&+0]\)"
    1              0.000010 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\$\|@@\=\)\=\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*"
    1              0.000010 syn match  rubySymbol		"[]})\"':]\@1<!:\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\%([?!=]>\@!\)\="
                            
    1   0.000014   0.000009 if s:foldable(':')
    1              0.000023   syn region rubySymbol		start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape fold
    1              0.000013   syn region rubySymbol		start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial fold
    1              0.000002 else
                              syn region rubySymbol		start="[]})\"':]\@1<!:'"  end="'"  skip="\\\\\|\\'"  contains=rubyQuoteEscape
                              syn region rubySymbol		start="[]})\"':]\@1<!:\"" end="\"" skip="\\\\\|\\\"" contains=@rubyStringSpecial
                            endif
                            
    1              0.000012 syn match  rubyCapitalizedMethod	"\%(\%(^\|[^.]\)\.\s*\)\@<!\<\u\%(\w\|[^\x00-\x7F]\)*\>\%(\s*(\)*\s*(\@="
                            
    1              0.000009 syn match  rubyBlockParameter	  "\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*" contained
    1              0.000019 syn region rubyBlockParameterList start="\%(\%(\<do\>\|{\)\_s*\)\@32<=|" end="|" oneline display contains=rubyBlockParameter
                            
    1              0.000009 syn match rubyInvalidVariable	 "$[^ A-Za-z_-]"
    1              0.000008 syn match rubyPredefinedVariable #$[!$&"'*+,./0:;<=>?@\`~]#
    1              0.000008 syn match rubyPredefinedVariable "$\d\+"										   display
    1              0.000027 syn match rubyPredefinedVariable "$_\>"											   display
    1              0.000008 syn match rubyPredefinedVariable "$-[0FIKadilpvw]\>"									   display
    1              0.000010 syn match rubyPredefinedVariable "$\%(deferr\|defout\|stderr\|stdin\|stdout\)\>"					   display
    1              0.000011 syn match rubyPredefinedVariable "$\%(DEBUG\|FILENAME\|KCODE\|LOADED_FEATURES\|LOAD_PATH\|PROGRAM_NAME\|SAFE\|VERBOSE\)\>" display
    1              0.000013 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(ARGF\|ARGV\|ENV\|DATA\|FALSE\|NIL\|STDERR\|STDIN\|STDOUT\|TOPLEVEL_BINDING\|TRUE\)\>\%(\s*(\)\@!"
    1              0.000014 syn match rubyPredefinedConstant "\%(\%(^\|[^.]\)\.\s*\)\@<!\<\%(RUBY_\%(VERSION\|RELEASE_DATE\|PLATFORM\|PATCHLEVEL\|REVISION\|DESCRIPTION\|COPYRIGHT\|ENGINE\)\)\>\%(\s*(\)\@!"
                            
                            " Normal Regular Expression {{{1
    1   0.000018   0.000013 if s:foldable('/')
    1              0.000026   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    1              0.000039   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial fold
    1              0.000001 else
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\%(^\|\<\%(and\|or\|while\|until\|unless\|if\|elsif\|when\|not\|then\|else\)\|[;\~=!|&(,{[<>?:*+-]\)\s*\)\@<=/" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="\%(\h\k*\s\+\)\@<=/[ \t=]\@!" end="/[iomxneus]*" skip="\\\\\|\\/" contains=@rubyRegexpSpecial
                            endif
                            
                            " Generalized Regular Expression {{{1
    1   0.000007   0.000003 if s:foldable('%')
    1              0.000019   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    1              0.000015   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial fold
    1              0.000032   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape fold
    1              0.000016   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial fold
    1              0.000014   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial fold
    1              0.000015   syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z(\s\)"				end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial fold
    1              0.000001 else
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r{"				end="}[iomxneus]*"   skip="\\\\\|\\}"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r<"				end=">[iomxneus]*"   skip="\\\\\|\\>"	 contains=@rubyRegexpSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\["				end="\][iomxneus]*"  skip="\\\\\|\\\]"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r("				end=")[iomxneus]*"   skip="\\\\\|\\)"	 contains=@rubyRegexpSpecial
                              syn region rubyRegexp matchgroup=rubyRegexpDelimiter start="%r\z(\s\)"				end="\z1[iomxneus]*" skip="\\\\\|\\\z1" contains=@rubyRegexpSpecial
                            endif
                            
                            " Normal String {{{1
    1              0.000004 let s:spell_cluster = exists('ruby_spellcheck_strings') ? ',@Spell' : ''
    1   0.000028   0.000024 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="\"" end="\"" skip="\\\\\|\\\"" ' .
                                  \ (s:foldable('%') ? 'fold' : '') . ' contains=@rubyStringSpecial' . s:spell_cluster
    1   0.000037   0.000034 exe 'syn region rubyString matchgroup=rubyStringDelimiter start="''" end="''" skip="\\\\\|\\''" ' .
                                  \ (s:foldable('%') ? 'fold' : '') . ' contains=rubyQuoteEscape'	 . s:spell_cluster
                            
                            " Shell Command Output {{{1
    1   0.000006   0.000003 if s:foldable('%')
    1              0.000037   syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial fold
    1              0.000000 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="`" end="`" skip="\\\\\|\\`" contains=@rubyStringSpecial
                            endif
                            
                            " Generalized Single Quoted String, Symbol and Array of Strings {{{1
    1   0.000007   0.000004 if s:foldable('%')
    1              0.000017   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" fold
    1              0.000031   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				     end="}"   skip="\\\\\|\\}"	  fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    1              0.000030   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				     end=">"   skip="\\\\\|\\>"	  fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    1              0.000030   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				     end="\]"  skip="\\\\\|\\\]"  fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    1              0.000029   syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				     end=")"   skip="\\\\\|\\)"	  fold contains=rubyNestedParentheses,rubyDelimiterEscape
    1              0.000014   syn region rubyString matchgroup=rubyStringDelimiter start="%q\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1" fold
    1              0.000015   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)"    end="\z1" skip="\\\\\|\\\z1" fold
    1              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				     end="}"   skip="\\\\\|\\}"	  fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    1              0.000053   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				     end=">"   skip="\\\\\|\\>"	  fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    1              0.000030   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				     end="\]"  skip="\\\\\|\\\]"  fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    1              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				     end=")"   skip="\\\\\|\\)"	  fold contains=rubyNestedParentheses,rubyDelimiterEscape
    1              0.000013   syn region rubyString matchgroup=rubyStringDelimiter start="%s\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1" fold
    1              0.000001 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]{"				     end="}"   skip="\\\\\|\\}"	  contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]<"				     end=">"   skip="\\\\\|\\>"	  contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]\["				     end="\]"  skip="\\\\\|\\\]"  contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[qw]("				     end=")"   skip="\\\\\|\\)"	  contains=rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%q\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)"    end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s{"				     end="}"   skip="\\\\\|\\}"	  contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s<"				     end=">"   skip="\\\\\|\\>"	  contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s\["				     end="\]"  skip="\\\\\|\\\]"  contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%s("				     end=")"   skip="\\\\\|\\)"	  contains=rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%s\z(\s\)"			     end="\z1" skip="\\\\\|\\\z1"
                            endif
                            
                            " Generalized Double Quoted String and Array of Strings and Shell Command Output {{{1
                            " Note: %= is not matched here as the beginning of a double quoted string
    1   0.000006   0.000003 if s:foldable('%')
    1              0.000018   syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    1              0.000016   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    1              0.000060   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"			      end="}"	skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape    fold
    1              0.000031   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"			      end=">"	skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape  fold
    1              0.000030   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["			      end="\]"	skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape fold
    1              0.000055   syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("			      end=")"	skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape    fold
    1              0.000015   syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx]\z(\s\)"			      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial fold
    1              0.000000 else
                              syn region rubyString matchgroup=rubyStringDelimiter start="%\z([~`!@#$%^&*_\-+|\:;"',.?/]\)"	      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\={"			      end="}"	skip="\\\\\|\\}"   contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=<"			      end=">"	skip="\\\\\|\\>"   contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=\["			      end="\]"	skip="\\\\\|\\\]"  contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[QWx]\=("			      end=")"	skip="\\\\\|\\)"   contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape
                              syn region rubyString matchgroup=rubyStringDelimiter start="%[Qx]\z(\s\)"			      end="\z1" skip="\\\\\|\\\z1" contains=@rubyStringSpecial
                            endif
                            
                            " Array of Symbols {{{1
    1   0.000006   0.000002 if s:foldable('%')
                              " Array of Symbols
    1              0.000016   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	fold
    1              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				  end="}"   skip="\\\\\|\\}"	fold contains=rubyNestedCurlyBraces,rubyDelimiterEscape
    1              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				  end=">"   skip="\\\\\|\\>"	fold contains=rubyNestedAngleBrackets,rubyDelimiterEscape
    1              0.000028   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				  end="\]"  skip="\\\\\|\\\]"	fold contains=rubyNestedSquareBrackets,rubyDelimiterEscape
    1              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				  end=")"   skip="\\\\\|\\)"	fold contains=rubyNestedParentheses,rubyDelimiterEscape
                            
                              " Array of interpolated Symbols
    1              0.000018   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	contains=@rubyStringSpecial fold
    1              0.000030   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I{"				  end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape    fold
    1              0.000047   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I<"				  end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape  fold
    1              0.000030   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\["				  end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape fold
    1              0.000029   syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I("				  end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape    fold
    1              0.000001 else
                              " Array of Symbols
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i{"				  end="}"   skip="\\\\\|\\}"	contains=rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i<"				  end=">"   skip="\\\\\|\\>"	contains=rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i\["				  end="\]"  skip="\\\\\|\\\]"	contains=rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%i("				  end=")"   skip="\\\\\|\\)"	contains=rubyNestedParentheses,rubyDelimiterEscape
                            
                              " Array of interpolated Symbols
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\z([~`!@#$%^&*_\-+=|\:;"',.?/]\)" end="\z1" skip="\\\\\|\\\z1"	contains=@rubyStringSpecial
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I{"				  end="}"   skip="\\\\\|\\}"	contains=@rubyStringSpecial,rubyNestedCurlyBraces,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I<"				  end=">"   skip="\\\\\|\\>"	contains=@rubyStringSpecial,rubyNestedAngleBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I\["				  end="\]"  skip="\\\\\|\\\]"	contains=@rubyStringSpecial,rubyNestedSquareBrackets,rubyDelimiterEscape
                              syn region rubySymbol matchgroup=rubySymbolDelimiter start="%I("				  end=")"   skip="\\\\\|\\)"	contains=@rubyStringSpecial,rubyNestedParentheses,rubyDelimiterEscape
                            endif
                            
                            " Here Document {{{1
    1              0.000022 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs\%(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)+	 end=+$+ oneline contains=ALLBUT,@rubyNotTop
    1              0.000019 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs"\%([^"]*\)"+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    1              0.000016 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs'\%([^']*\)'+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
    1              0.000016 syn region rubyHeredocStart matchgroup=rubyStringDelimiter start=+\%(\%(class\s*\|\%([]})"'.]\|::\)\)\_s*\|\w\)\@<!<<[-~]\=\zs`\%([^`]*\)`+ end=+$+ oneline contains=ALLBUT,@rubyNotTop
                            
    1   0.000007   0.000003 if s:foldable('<<')
    1              0.000037   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    1              0.000034   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
    1              0.000031   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc		    fold keepend
    1              0.000031   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial fold keepend
                            
    1              0.000028   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    1              0.000025   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    1              0.000024   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		    fold keepend
    1              0.000024   syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial fold keepend
    1              0.000002 else
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc		    keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]})"'.]\)\s\|\w\)\@<!<<`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+2	matchgroup=rubyStringDelimiter end=+^\z1$+ contains=rubyHeredocStart,rubyHeredoc,@rubyStringSpecial keepend
                            
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]\z(\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*\)\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3    matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]"\z([^"]*\)"\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]'\z([^']*\)'\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart		    keepend
                              syn region rubyString start=+\%(\%(class\|::\)\_s*\|\%([]}).]\)\s\|\w\)\@<!<<[-~]`\z([^`]*\)`\ze\%(.*<<[-~]\=['`"]\=\h\)\@!+hs=s+3  matchgroup=rubyStringDelimiter end=+^\s*\zs\z1$+ contains=rubyHeredocStart,@rubyStringSpecial keepend
                            endif
                            
                            " eRuby Config {{{1
    1              0.000005 if exists('main_syntax') && main_syntax == 'eruby'
    1              0.000002   let b:ruby_no_expensive = 1
    1              0.000001 end
                            
                            " Module, Class, Method and Alias Declarations {{{1
    1              0.000042 syn match  rubyAliasDeclaration    "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable nextgroup=rubyAliasDeclaration2 skipwhite
    1              0.000032 syn match  rubyAliasDeclaration2   "[^[:space:];#.()]\+" contained contains=rubySymbol,rubyGlobalVariable,rubyPredefinedVariable
    1              0.000053 syn match  rubyMethodDeclaration   "[^[:space:];#(]\+"	 contained contains=rubyConstant,rubyBoolean,rubyPseudoVariable,rubyInstanceVariable,rubyClassVariable,rubyGlobalVariable
    1              0.000022 syn match  rubyClassDeclaration    "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    1              0.000021 syn match  rubyModuleDeclaration   "[^[:space:];#<]\+"	 contained contains=rubyConstant,rubyOperator
    1              0.000018 syn match  rubyFunction "\<[_[:alpha:]][_[:alnum:]]*[?!=]\=[[:alnum:]_.:?!=]\@!" contained containedin=rubyMethodDeclaration
    1              0.000028 syn match  rubyFunction "\%(\s\|^\)\@1<=[_[:alpha:]][_[:alnum:]]*[?!=]\=\%(\s\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2
    1              0.000035 syn match  rubyFunction "\%([[:space:].]\|^\)\@2<=\%(\[\]=\=\|\*\*\|[-+!~]@\=\|[*/%|&^~]\|<<\|>>\|[<>]=\=\|<=>\|===\|[=!]=\|[=!]\~\|!\|`\)\%([[:space:];#(]\|$\)\@=" contained containedin=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration
                            
    1              0.000053 syn cluster rubyDeclaration contains=rubyAliasDeclaration,rubyAliasDeclaration2,rubyMethodDeclaration,rubyModuleDeclaration,rubyClassDeclaration,rubyFunction,rubyBlockParameter
                            
                            " Keywords {{{1
                            " Note: the following keywords have already been defined:
                            " begin case class def do end for if module unless until while
    1              0.000013 syn match   rubyControl	       "\<\%(and\|break\|in\|next\|not\|or\|redo\|rescue\|retry\|return\)\>[?!]\@!"
    1              0.000008 syn match   rubyOperator       "\<defined?" display
    1              0.000008 syn match   rubyKeyword	       "\<\%(super\|yield\)\>[?!]\@!"
    1              0.000008 syn match   rubyBoolean	       "\<\%(true\|false\)\>[?!]\@!"
    1              0.000012 syn match   rubyPseudoVariable "\<\%(nil\|self\|__ENCODING__\|__dir__\|__FILE__\|__LINE__\|__callee__\|__method__\)\>[?!]\@!" " TODO: reorganise
    1              0.000008 syn match   rubyBeginEnd       "\<\%(BEGIN\|END\)\>[?!]\@!"
                            
                            " Expensive Mode {{{1
                            " Match 'end' with the appropriate opening keyword for syntax based folding
                            " and special highlighting of module/class/method definitions
    1              0.000004 if !exists("b:ruby_no_expensive") && !exists("ruby_no_expensive")
                              syn match  rubyDefine "\<alias\>"  nextgroup=rubyAliasDeclaration  skipwhite skipnl
                              syn match  rubyDefine "\<def\>"    nextgroup=rubyMethodDeclaration skipwhite skipnl
                              syn match  rubyDefine "\<undef\>"  nextgroup=rubyFunction	     skipwhite skipnl
                              syn match  rubyClass	"\<class\>"  nextgroup=rubyClassDeclaration  skipwhite skipnl
                              syn match  rubyModule "\<module\>" nextgroup=rubyModuleDeclaration skipwhite skipnl
                            
                              if s:foldable('def')
                                syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyMethodBlock start="\<def\>"	matchgroup=rubyDefine end="\%(\<def\_s\+\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              if s:foldable('class')
                                syn region rubyBlock start="\<class\>"	matchgroup=rubyClass end="\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyBlock start="\<class\>"	matchgroup=rubyClass end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              if s:foldable('module')
                                syn region rubyBlock start="\<module\>" matchgroup=rubyModule end="\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyBlock start="\<module\>" matchgroup=rubyModule end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " modifiers
                              syn match rubyLineContinuation    "\\$" nextgroup=rubyConditionalModifier,rubyRepeatModifier skipwhite skipnl
                              syn match rubyConditionalModifier "\<\%(if\|unless\)\>"
                              syn match rubyRepeatModifier	    "\<\%(while\|until\)\>"
                            
                              if s:foldable('do')
                                syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyDoBlock matchgroup=rubyControl start="\<do\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " curly bracket block or hash literal
                              if s:foldable('{')
                                syn region rubyCurlyBlock matchgroup=rubyCurlyBlockDelimiter start="{" end="}" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyCurlyBlock matchgroup=rubyCurlyBlockDelimiter start="{" end="}" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              if s:foldable('[')
                                syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter start="\%(\w\|[\]})]\)\@<!\[" end="]" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyArrayLiteral	matchgroup=rubyArrayDelimiter start="\%(\w\|[\]})]\)\@<!\[" end="]" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              " statements without 'do'
                              if s:foldable('begin')
                                syn region rubyBlockExpression matchgroup=rubyControl start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyBlockExpression matchgroup=rubyControl start="\<begin\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              if s:foldable('case')
                                syn region rubyCaseExpression matchgroup=rubyConditional start="\<case\>" end="\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyCaseExpression matchgroup=rubyConditional start="\<case\>" end="\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              if s:foldable('if')
                                syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@1<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop fold
                              else
                                syn region rubyConditionalExpression matchgroup=rubyConditional start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*%&^|+=-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![?!]\)\s*\)\@<=\%(if\|unless\)\>" end="\%(\%(\%(\.\@1<!\.\)\|::\)\s*\)\@<!\<end\>" contains=ALLBUT,@rubyNotTop
                              endif
                            
                              syn match rubyConditional "\<\%(then\|else\|when\)\>[?!]\@!"	contained containedin=rubyCaseExpression
                              syn match rubyConditional "\<\%(then\|else\|elsif\)\>[?!]\@!" contained containedin=rubyConditionalExpression
                            
                              syn match rubyExceptional	  "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyBlockExpression
                              syn match rubyMethodExceptional "\<\%(\%(\%(;\|^\)\s*\)\@<=rescue\|else\|ensure\)\>[?!]\@!" contained containedin=rubyMethodBlock
                            
                              " statements with optional 'do'
                              syn region rubyOptionalDoLine   matchgroup=rubyRepeat start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyOptionalDo end="\%(\<do\>\)" end="\ze\%(;\|$\)" oneline contains=ALLBUT,@rubyNotTop
                            
                              if s:foldable('for')
                                syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine fold
                              else
                                syn region rubyRepeatExpression start="\<for\>[?!]\@!" start="\%(\%(^\|\.\.\.\=\|[{:,;([<>~\*/%&^|+-]\|\%(\<[_[:lower:]][_[:alnum:]]*\)\@<![!=?]\)\s*\)\@<=\<\%(until\|while\)\>" matchgroup=rubyRepeat end="\<end\>" contains=ALLBUT,@rubyNotTop nextgroup=rubyOptionalDoLine
                              endif
                            
                              if !exists("ruby_minlines")
                                let ruby_minlines = 500
                              endif
                              exec "syn sync minlines=" . ruby_minlines
                            
                            else
    1              0.000017   syn match rubyControl "\<def\>[?!]\@!"    nextgroup=rubyMethodDeclaration skipwhite skipnl
    1              0.000016   syn match rubyControl "\<class\>[?!]\@!"  nextgroup=rubyClassDeclaration  skipwhite skipnl
    1              0.000015   syn match rubyControl "\<module\>[?!]\@!" nextgroup=rubyModuleDeclaration skipwhite skipnl
    1              0.000012   syn match rubyControl "\<\%(case\|begin\|do\|for\|if\|unless\|while\|until\|else\|elsif\|ensure\|then\|when\|end\)\>[?!]\@!"
    1              0.000008   syn match rubyKeyword "\<\%(alias\|undef\)\>[?!]\@!"
    1              0.000001 endif
                            
                            " Special Methods {{{1
    1              0.000003 if !exists("ruby_no_special_methods")
    1              0.000011   syn keyword rubyAccess    public protected private public_class_method private_class_method public_constant private_constant module_function
                              " attr is a common variable name
    1              0.000010   syn match   rubyAttribute "\%(\%(^\|;\)\s*\)\@<=attr\>\(\s*[.=]\)\@!"
    1              0.000007   syn keyword rubyAttribute attr_accessor attr_reader attr_writer
    1              0.000010   syn match   rubyControl   "\<\%(exit!\|\%(abort\|at_exit\|exit\|fork\|loop\|trap\)\>[?!]\@!\)"
    1              0.000008   syn keyword rubyEval	    eval class_eval instance_eval module_eval
    1              0.000007   syn keyword rubyException raise fail catch throw
                              " false positive with 'include?'
    1              0.000008   syn match   rubyInclude   "\<include\>[?!]\@!"
    1              0.000008   syn keyword rubyInclude   autoload extend load prepend refine require require_relative using
    1              0.000007   syn keyword rubyKeyword   callcc caller lambda proc
    1              0.000001 endif
                            
                            " Comments and Documentation {{{1
    1              0.000008 syn match   rubySharpBang "\%^#!.*" display
    1              0.000008 syn keyword rubyTodo	  FIXME NOTE TODO OPTIMIZE HACK REVIEW XXX todo contained
    1              0.000031 syn match   rubyComment   "#.*" contains=rubySharpBang,rubySpaceError,rubyTodo,@Spell
    1   0.000011   0.000007 if !exists("ruby_no_comment_fold") && s:foldable('#')
    1              0.000021   syn region rubyMultilineComment start="^\s*#.*\n\%(^\s*#\)\@=" end="^\s*#.*\n\%(^\s*#\)\@!" contains=rubyComment transparent fold keepend
    1              0.000028   syn region rubyDocumentation	  start="^=begin\ze\%(\s.*\)\=$" end="^=end\%(\s.*\)\=$" contains=rubySpaceError,rubyTodo,@Spell fold
    1              0.000001 else
                              syn region rubyDocumentation	  start="^=begin\s*$" end="^=end\s*$" contains=rubySpaceError,rubyTodo,@Spell
                            endif
                            
                            " Keyword Nobbling {{{1
                            " Note: this is a hack to prevent 'keywords' being highlighted as such when called as methods with an explicit receiver
    1              0.000022 syn match rubyKeywordAsMethod "\%(\%(\.\@1<!\.\)\|::\)\_s*\%([_[:lower:]][_[:alnum:]]*\|\<\%(BEGIN\|END\)\>\)" transparent contains=NONE
    1              0.000021 syn match rubyKeywordAsMethod "\(defined?\|exit!\)\@!\<[_[:lower:]][_[:alnum:]]*[?!]"			       transparent contains=NONE
                            
                            " More Symbols {{{1
    1              0.000017 syn match  rubySymbol		"\%([{(,]\_s*\)\zs\l\w*[!?]\=::\@!"he=e-1
    1              0.000014 syn match  rubySymbol		"[]})\"':]\@1<!\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="he=e-1
    1              0.000010 syn match  rubySymbol		"\%([{(,]\_s*\)\zs[[:space:],{]\l\w*[!?]\=::\@!"hs=s+1,he=e-1
    1              0.000011 syn match  rubySymbol		"[[:space:],{(]\%(\h\|[^\x00-\x7F]\)\%(\w\|[^\x00-\x7F]\)*[!?]\=:[[:space:],]\@="hs=s+1,he=e-1
                            
                            " __END__ Directive {{{1
    1   0.000008   0.000004 if s:foldable('__END__')
    1              0.000015   syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$" fold
    1              0.000001 else
                              syn region rubyData matchgroup=rubyDataDirective start="^__END__$" end="\%$"
                            endif
                            
                            " Default Highlighting {{{1
    1              0.000011 hi def link rubyClass			rubyDefine
    1              0.000009 hi def link rubyModule			rubyDefine
    1              0.000008 hi def link rubyMethodExceptional	rubyDefine
    1              0.000009 hi def link rubyDefine			Define
    1              0.000008 hi def link rubyFunction		Function
    1              0.000008 hi def link rubyConditional		Conditional
    1              0.000007 hi def link rubyConditionalModifier	rubyConditional
    1              0.000008 hi def link rubyExceptional		rubyConditional
    1              0.000008 hi def link rubyRepeat			Repeat
    1              0.000007 hi def link rubyRepeatModifier		rubyRepeat
    1              0.000007 hi def link rubyOptionalDo		rubyRepeat
    1              0.000007 hi def link rubyControl			Statement
    1              0.000008 hi def link rubyInclude			Include
    1              0.000008 hi def link rubyInteger			Number
    1              0.000007 hi def link rubyASCIICode		Character
    1              0.000007 hi def link rubyFloat			Float
    1              0.000008 hi def link rubyBoolean			Boolean
    1              0.000008 hi def link rubyException		Exception
    1              0.000002 if !exists("ruby_no_identifiers")
    1              0.000009   hi def link rubyIdentifier		Identifier
    1              0.000001 else
                              hi def link rubyIdentifier		NONE
                            endif
    1              0.000008 hi def link rubyClassVariable		rubyIdentifier
    1              0.000008 hi def link rubyConstant		Type
    1              0.000008 hi def link rubyGlobalVariable		rubyIdentifier
    1              0.000008 hi def link rubyBlockParameter		rubyIdentifier
    1              0.000007 hi def link rubyInstanceVariable	rubyIdentifier
    1              0.000007 hi def link rubyPredefinedIdentifier	rubyIdentifier
    1              0.000008 hi def link rubyPredefinedConstant	rubyPredefinedIdentifier
    1              0.000007 hi def link rubyPredefinedVariable	rubyPredefinedIdentifier
    1              0.000008 hi def link rubySymbol			Constant
    1              0.000008 hi def link rubyKeyword			Keyword
    1              0.000007 hi def link rubyOperator		Operator
    1              0.000008 hi def link rubyBeginEnd		Statement
    1              0.000008 hi def link rubyAccess			Statement
    1              0.000008 hi def link rubyAttribute		Statement
    1              0.000007 hi def link rubyEval			Statement
    1              0.000008 hi def link rubyPseudoVariable		Constant
    1              0.000008 hi def link rubyCapitalizedMethod	rubyLocalVariableOrMethod
                            
    1              0.000008 hi def link rubyComment			Comment
    1              0.000007 hi def link rubyData			Comment
    1              0.000008 hi def link rubyDataDirective		Delimiter
    1              0.000008 hi def link rubyDocumentation		Comment
    1              0.000008 hi def link rubyTodo			Todo
                            
    1              0.000008 hi def link rubyQuoteEscape		rubyStringEscape
    1              0.000008 hi def link rubyStringEscape		Special
    1              0.000008 hi def link rubyInterpolationDelimiter	Delimiter
    1              0.000008 hi def link rubyNoInterpolation		rubyString
    1              0.000008 hi def link rubySharpBang		PreProc
    1              0.000008 hi def link rubyRegexpDelimiter		rubyStringDelimiter
    1              0.000007 hi def link rubySymbolDelimiter		rubySymbol
    1              0.000008 hi def link rubyStringDelimiter		Delimiter
    1              0.000007 hi def link rubyHeredoc			rubyString
    1              0.000008 hi def link rubyString			String
    1              0.000008 hi def link rubyRegexpEscape		rubyRegexpSpecial
    1              0.000008 hi def link rubyRegexpQuantifier	rubyRegexpSpecial
    1              0.000007 hi def link rubyRegexpAnchor		rubyRegexpSpecial
    1              0.000008 hi def link rubyRegexpDot		rubyRegexpCharClass
    1              0.000008 hi def link rubyRegexpCharClass		rubyRegexpSpecial
    1              0.000008 hi def link rubyRegexpSpecial		Special
    1              0.000008 hi def link rubyRegexpComment		Comment
    1              0.000007 hi def link rubyRegexp			rubyString
                            
    1              0.000008 hi def link rubyInvalidVariable		Error
    1              0.000007 hi def link rubyError			Error
    1              0.000007 hi def link rubySpaceError		rubyError
                            
                            " Postscript {{{1
    1              0.000002 let b:current_syntax = "ruby"
                            
    1              0.000008 let &cpo = s:cpo_sav
    1              0.000001 unlet! s:cpo_sav
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet fdm=marker:

SCRIPT  /usr/share/vim/vim81/ftplugin/eruby.vim
Sourced 1 time
Total time:   0.005058
 Self time:   0.003501

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		eRuby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
                            " Only do this when not done yet for this buffer
    1              0.000015 if exists("b:did_ftplugin")
                              finish
                            endif
                            
    1              0.000021 let s:save_cpo = &cpo
    1              0.000029 set cpo-=C
                            
                            " Define some defaults in case the included ftplugins don't set them.
    1              0.000007 let s:undo_ftplugin = ""
    1              0.000006 let s:browsefilter = "All Files (*.*)\t*.*\n"
    1              0.000005 let s:match_words = ""
                            
    1              0.000010 if !exists("g:eruby_default_subtype")
                              let g:eruby_default_subtype = "html"
                            endif
                            
    1              0.000019 if &filetype =~ '^eruby\.'
                              let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
                            elseif !exists("b:eruby_subtype")
    1              0.000034   let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
    1              0.000053   let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
    1              0.000007   if b:eruby_subtype == ''
    1              0.000069     let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\)\+$','',''),'\.\zs\w\+\%(\ze+\w\+\)\=$')
    1              0.000004   endif
    1              0.000005   if b:eruby_subtype == 'rhtml'
                                let b:eruby_subtype = 'html'
                              elseif b:eruby_subtype == 'rb'
                                let b:eruby_subtype = 'ruby'
                              elseif b:eruby_subtype == 'yml'
                                let b:eruby_subtype = 'yaml'
                              elseif b:eruby_subtype == 'js'
                                let b:eruby_subtype = 'javascript'
                              elseif b:eruby_subtype == 'txt'
                                " Conventional; not a real file type
                                let b:eruby_subtype = 'text'
                              elseif b:eruby_subtype == ''
                                let b:eruby_subtype = g:eruby_default_subtype
                              endif
    1              0.000002 endif
                            
    1              0.000010 if exists("b:eruby_subtype") && b:eruby_subtype != ''
    1   0.002372   0.002017   exe "runtime! ftplugin/".b:eruby_subtype.".vim ftplugin/".b:eruby_subtype."_*.vim ftplugin/".b:eruby_subtype."/*.vim"
    1              0.000002 else
                              runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
                            endif
    1              0.000003 unlet! b:did_ftplugin
                            
                            " Override our defaults if these were set by an included ftplugin.
    1              0.000006 if exists("b:undo_ftplugin")
    1              0.000004   let s:undo_ftplugin = b:undo_ftplugin
    1              0.000002   unlet b:undo_ftplugin
    1              0.000001 endif
    1              0.000004 if exists("b:browsefilter")
                              let s:browsefilter = b:browsefilter
                              unlet b:browsefilter
                            endif
    1              0.000003 if exists("b:match_words")
                              let s:match_words = b:match_words
                              unlet b:match_words
                            endif
                            
    1   0.002189   0.000987 runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
    1              0.000003 let b:did_ftplugin = 1
                            
                            " Combine the new set of values with those previously included.
    1              0.000003 if exists("b:undo_ftplugin")
    1              0.000004   let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
    1              0.000001 endif
    1              0.000002 if exists ("b:browsefilter")
    1              0.000008   let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
    1              0.000000 endif
    1              0.000002 if exists("b:match_words")
                              let s:match_words = b:match_words . ',' . s:match_words
                            endif
                            
                            " Change the browse dialog on Win32 to show mainly eRuby-related files
    1              0.000003 if has("gui_win32")
                              let b:browsefilter="eRuby Files (*.erb, *.rhtml)\t*.erb;*.rhtml\n" . s:browsefilter
                            endif
                            
                            " Load the combined list of match_words for matchit.vim
    1              0.000002 if exists("loaded_matchit")
                              let b:match_words = s:match_words
                            endif
                            
                            " TODO: comments=
    1              0.000004 setlocal commentstring=<%#%s%>
                            
    1              0.000002 let b:undo_ftplugin = "setl cms< "
                                  \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin
                            
    1              0.000006 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: nowrap sw=2 sts=2 ts=8:

SCRIPT  /usr/share/vim/vim81/ftplugin/html.vim
Sourced 1 time
Total time:   0.000339
 Self time:   0.000215

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    1              0.000017 if exists("b:did_ftplugin") | finish | endif
    1              0.000006 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    1              0.000018 let s:save_cpo = &cpo
    1              0.000066 set cpo-=C
                            
    1              0.000005 setlocal matchpairs+=<:>
    1              0.000003 setlocal commentstring=<!--%s-->
    1              0.000003 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    1              0.000004 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
                            endif
                            
    1              0.000001 if exists('&omnifunc')
    1              0.000003   setlocal omnifunc=htmlcomplete#CompleteTags
    1   0.000146   0.000022   call htmlcomplete#DetectOmniFlavor()
    1              0.000001 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
    1              0.000002 if exists("loaded_matchit")
                                let b:match_ignorecase = 1
                                let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
                            endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    1              0.000005 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
    1              0.000004 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    1              0.000008 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /usr/share/vim/vim81/indent/eruby.vim
Sourced 1 time
Total time:   0.000576
 Self time:   0.000380

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		eRuby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
    1              0.000003 if exists("b:did_indent")
                              finish
                            endif
                            
    1   0.000214   0.000168 runtime! indent/ruby.vim
    1              0.000002 unlet! b:did_indent
    1              0.000002 setlocal indentexpr=
                            
    1              0.000002 if exists("b:eruby_subtype")
    1   0.000321   0.000171   exe "runtime! indent/".b:eruby_subtype.".vim"
    1              0.000001 else
                              runtime! indent/html.vim
                            endif
    1              0.000001 unlet! b:did_indent
                            
                            " Force HTML indent to not keep state.
    1              0.000002 let b:html_indent_usestate = 0
                            
    1              0.000001 if &l:indentexpr == ''
                              if &l:cindent
                                let &l:indentexpr = 'cindent(v:lnum)'
                              else
                                let &l:indentexpr = 'indent(prevnonblank(v:lnum-1))'
                              endif
                            endif
    1              0.000003 let b:eruby_subtype_indentexpr = &l:indentexpr
                            
    1              0.000001 let b:did_indent = 1
                            
    1              0.000002 setlocal indentexpr=GetErubyIndent()
    1              0.000002 setlocal indentkeys=o,O,*<Return>,<>>,{,},0),0],o,O,!^F,=end,=else,=elsif,=rescue,=ensure,=when
                            
                            " Only define the function once.
    1              0.000002 if exists("*GetErubyIndent")
    1              0.000001   finish
                            endif
                            
                            " this file uses line continuations
                            let s:cpo_sav = &cpo
                            set cpo&vim
                            
                            function! GetErubyIndent(...)
                              " The value of a single shift-width
                              let sw = shiftwidth()
                            
                              if a:0 && a:1 == '.'
                                let v:lnum = line('.')
                              elseif a:0 && a:1 =~ '^\d'
                                let v:lnum = a:1
                              endif
                              let vcol = col('.')
                              call cursor(v:lnum,1)
                              let inruby = searchpair('<%','','%>','W')
                              call cursor(v:lnum,vcol)
                              if inruby && getline(v:lnum) !~ '^<%\|^\s*[-=]\=%>'
                                let ind = GetRubyIndent(v:lnum)
                              else
                                exe "let ind = ".b:eruby_subtype_indentexpr
                            
                                " Workaround for Andy Wokula's HTML indent. This should be removed after
                                " some time, since the newest version is fixed in a different way.
                                if b:eruby_subtype_indentexpr =~# '^HtmlIndent('
                            	  \ && exists('b:indent')
                            	  \ && type(b:indent) == type({})
                            	  \ && has_key(b:indent, 'lnum')
                                  " Force HTML indent to not keep state
                                  let b:indent.lnum = -1
                                endif
                              endif
                              let lnum = prevnonblank(v:lnum-1)
                              let line = getline(lnum)
                              let cline = getline(v:lnum)
                              if cline =~# '^\s*<%[-=]\=\s*\%(}\|end\|else\|\%(ensure\|rescue\|elsif\|when\).\{-\}\)\s*\%([-=]\=%>\|$\)'
                                let ind = ind - sw
                              endif
                              if line =~# '\S\s*<%[-=]\=\s*\%(}\|end\).\{-\}\s*\%([-=]\=%>\|$\)'
                                let ind = ind - sw
                              endif
                              if line =~# '\%({\|\<do\)\%(\s*|[^|]*|\)\=\s*[-=]\=%>'
                                let ind = ind + sw
                              elseif line =~# '<%[-=]\=\s*\%(module\|class\|def\|if\|for\|while\|until\|else\|elsif\|case\|when\|unless\|begin\|ensure\|rescue\)\>.*%>'
                                let ind = ind + sw
                              endif
                              if line =~# '^\s*<%[=#-]\=\s*$' && cline !~# '^\s*end\>'
                                let ind = ind + sw
                              endif
                              if line !~# '^\s*<%' && line =~# '%>\s*$' && line !~# '^\s*end\>'
                                let ind = ind - sw
                              endif
                              if cline =~# '^\s*[-=]\=%>\s*$'
                                let ind = ind - sw
                              endif
                              return ind
                            endfunction
                            
                            let &cpo = s:cpo_sav
                            unlet! s:cpo_sav
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  /usr/share/vim/vim81/indent/html.vim
Sourced 1 time
Total time:   0.000146
 Self time:   0.000049

count  total (s)   self (s)
                            " Vim indent script for HTML
                            " Header: "{{{
                            " Maintainer:	Bram Moolenaar
                            " Original Author: Andy Wokula <anwoku@yahoo.de>
                            " Last Change:	2018 Mar 28
                            " Version:	1.0
                            " Description:	HTML indent script with cached state for faster indenting on a
                            "		range of lines.
                            "		Supports template systems through hooks.
                            "		Supports Closure stylesheets.
                            "
                            " Credits:
                            "	indent/html.vim (2006 Jun 05) from J. Zellner
                            "	indent/css.vim (2006 Dec 20) from N. Weibull
                            "
                            " History:
                            " 2014 June	(v1.0) overhaul (Bram)
                            " 2012 Oct 21	(v0.9) added support for shiftwidth()
                            " 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
                            " 2008 Apr 28	(v0.6) revised customization
                            " 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
                            "}}}
                            
                            " Init Folklore, check user settings (2nd time ++)
    1              0.000003 if exists("b:did_indent") "{{{
                              finish
                            endif
                            
                            " Load the Javascript indent script first, it defines GetJavascriptIndent().
                            " Undo the rest.
                            " Load base python indent.
    1              0.000002 if !exists('*GetJavascriptIndent')
                              runtime! indent/javascript.vim
                            endif
    1              0.000001 let b:did_indent = 1
                            
    1              0.000002 setlocal indentexpr=HtmlIndent()
    1              0.000002 setlocal indentkeys=o,O,<Return>,<>>,{,},!^F
                            
                            " Needed for % to work when finding start/end of a tag.
    1              0.000001 setlocal matchpairs+=<:>
                            
    1              0.000001 let b:undo_indent = "setlocal inde< indk<"
                            
                            " b:hi_indent keeps state to speed up indenting consecutive lines.
    1              0.000002 let b:hi_indent = {"lnum": -1}
                            
                            """""" Code below this is loaded only once. """""
    1              0.000003 if exists("*HtmlIndent") && !exists('g:force_reload_html')
    1   0.000109   0.000012   call HtmlIndent_CheckUserSettings()
    1              0.000001   finish
                            endif
                            
                            " Allow for line continuation below.
                            let s:cpo_save = &cpo
                            set cpo-=C
                            "}}}
                            
                            " Pattern to match the name of a tag, including custom elements.
                            let s:tagname = '\w\+\(-\w\+\)*'
                            
                            " Check and process settings from b:html_indent and g:html_indent... variables.
                            " Prefer using buffer-local settings over global settings, so that there can
                            " be defaults for all HTML files and exceptions for specific types of HTML
                            " files.
                            func! HtmlIndent_CheckUserSettings()
                              "{{{
                              let inctags = ''
                              if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
                              let b:hi_tags = {}
                              if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
                              let autotags = ''
                              if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
                              let b:hi_removed_tags = {}
                              if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
                              let string_names = []
                              if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
                              let b:hi_insideStringNames = ['htmlString']
                              if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
                              let tag_names = []
                              if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
                              let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
                              if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
                              let indone = {"zero": 0
                                          \,"auto": "indent(prevnonblank(v:lnum-1))"
                                          \,"inc": "b:hi_indent.blocktagind + shiftwidth()"}
                            
                              let script1 = ''
                              if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
                                let script1 = g:html_indent_script1
                              endif
                              if len(script1) > 0
                                let b:hi_js1indent = get(indone, script1, indone.zero)
                              else
                                let b:hi_js1indent = 0
                              endif
                            
                              let style1 = ''
                              if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
                              if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
                                let b:hi_css1indent = 0
                              endif
                            
                              if !exists('b:html_indent_line_limit')
                                if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
                                  let b:html_indent_line_limit = 200
                                endif
                              endif
                            endfunc "}}}
                            
                            " Init Script Vars
                            "{{{
                            let b:hi_lasttick = 0
                            let b:hi_newstate = {}
                            let s:countonly = 0
                             "}}}
                            
                            " Fill the s:indent_tags dict with known tags.
                            " The key is "tagname" or "/tagname".  {{{
                            " The value is:
                            " 1   opening tag
                            " 2   "pre"
                            " 3   "script"
                            " 4   "style"
                            " 5   comment start
                            " 6   conditional comment start
                            " -1  closing tag
                            " -2  "/pre"
                            " -3  "/script"
                            " -4  "/style"
                            " -5  comment end
                            " -6  conditional comment end
                            let s:indent_tags = {}
                            let s:endtags = [0,0,0,0,0,0,0]   " long enough for the highest index
                            "}}}
                            
                            " Add a list of tag names for a pair of <tag> </tag> to "tags".
                            func! s:AddITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = -1
                              endfor
                            endfunc "}}}
                            
                            " Take a list of tag name pairs that are not to be used as tag pairs.
                            func! s:RemoveITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = 1
                              endfor
                            endfunc "}}}
                            
                            " Add a block tag, that is a tag with a different kind of indenting.
                            func! s:AddBlockTag(tag, id, ...)
                              "{{{
                              if !(a:id >= 2 && a:id < len(s:endtags))
                                echoerr 'AddBlockTag ' . a:id
                                return
                              endif
                              let s:indent_tags[a:tag] = a:id
                              if a:0 == 0
                                let s:indent_tags['/' . a:tag] = -a:id
                                let s:endtags[a:id] = "</" . a:tag . ">"
                              else
                                let s:indent_tags[a:1] = -a:id
                                let s:endtags[a:id] = a:1
                              endif
                            endfunc "}}}
                            
                            " Add known tag pairs.
                            " Self-closing tags and tags that are sometimes {{{
                            " self-closing (e.g., <p>) are not here (when encountering </p> we can find
                            " the matching <p>, but not the other way around).  Known self-closing tags:
                            " 'p', 'img', 'source'.
                            " Old HTML tags:
                            call s:AddITags(s:indent_tags, [
                                \ 'a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
                                \ 'blockquote', 'body', 'button', 'caption', 'center', 'cite', 'code',
                                \ 'colgroup', 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font',
                                \ 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html',
                                \ 'i', 'iframe', 'ins', 'kbd', 'label', 'legend', 'li',
                                \ 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
                                \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
                                \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
                                \ 'tr', 'tbody', 'tfoot', 'thead'])
                            
                            " New HTML5 elements:
                            call s:AddITags(s:indent_tags, [
                                \ 'area', 'article', 'aside', 'audio', 'bdi', 'canvas',
                                \ 'command', 'data', 'datalist', 'details', 'embed', 'figcaption',
                                \ 'figure', 'footer', 'header', 'keygen', 'main', 'mark', 'meter',
                                \ 'nav', 'output', 'picture', 'progress', 'rp', 'rt', 'ruby', 'section',
                                \ 'summary', 'svg', 'time', 'track', 'video', 'wbr'])
                            
                            " Tags added for web components:
                            call s:AddITags(s:indent_tags, [
                                \ 'content', 'shadow', 'template'])
                            "}}}
                            
                            " Add Block Tags: these contain alien content
                            "{{{
                            call s:AddBlockTag('pre', 2)
                            call s:AddBlockTag('script', 3)
                            call s:AddBlockTag('style', 4)
                            call s:AddBlockTag('<!--', 5, '-->')
                            call s:AddBlockTag('<!--[', 6, '![endif]-->')
                            "}}}
                            
                            " Return non-zero when "tagname" is an opening tag, not being a block tag, for
                            " which there should be a closing tag.  Can be used by scripts that include
                            " HTML indenting.
                            func! HtmlIndent_IsOpenTag(tagname)
                              "{{{
                              if get(s:indent_tags, a:tagname) == 1
                                return 1
                              endif
                              return get(b:hi_tags, a:tagname) == 1
                            endfunc "}}}
                            
                            " Get the value for "tagname", taking care of buffer-local tags.
                            func! s:get_tag(tagname)
                              "{{{
                              let i = get(s:indent_tags, a:tagname)
                              if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
                                return 0
                              endif
                              if i == 0
                                let i = get(b:hi_tags, a:tagname)
                              endif
                              return i
                            endfunc "}}}
                            
                            " Count the number of start and end tags in "text".
                            func! s:CountITags(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                              let s:block = 0		" assume starting outside of a block
                              let s:countonly = 1	" don't change state
                              call substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              let s:countonly = 0
                            endfunc "}}}
                            
                            " Count the number of start and end tags in text.
                            func! s:CountTagsAndState(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
                              let s:block = b:hi_newstate.block
                              let tmp = substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
                              endif
                              let b:hi_newstate.block = s:block
                            endfunc "}}}
                            
                            " Used by s:CountITags() and s:CountTagsAndState().
                            func! s:CheckTag(itag)
                              "{{{
                              " Returns an empty string or "SCRIPT".
                              " a:itag can be "tag" or "/tag" or "<!--" or "-->"
                              if (s:CheckCustomTag(a:itag))
                                return ""
                              endif
                              let ind = s:get_tag(a:itag)
                              if ind == -1
                                " closing tag
                                if s:block != 0
                                  " ignore itag within a block
                                  return ""
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              elseif ind == 1
                                " opening tag
                                if s:block != 0
                                  return ""
                                endif
                                let s:nextrel += 1
                              elseif ind != 0
                                " block-tag (opening or closing)
                                return s:CheckBlockTag(a:itag, ind)
                              " else ind==0 (other tag found): keep indent
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag(). Returns an empty string or "SCRIPT".
                            func! s:CheckBlockTag(blocktag, ind)
                              "{{{
                              if a:ind > 0
                                " a block starts here
                                if s:block != 0
                                  " already in a block (nesting) - ignore
                                  " especially ignore comments after other blocktags
                                  return ""
                                endif
                                let s:block = a:ind		" block type
                                if s:countonly
                                  return ""
                                endif
                                let b:hi_newstate.blocklnr = v:lnum
                                " save allover indent for the endtag
                                let b:hi_newstate.blocktagind = b:hi_indent.baseindent + (s:nextrel + s:curind) * shiftwidth()
                                if a:ind == 3
                                  return "SCRIPT"    " all except this must be lowercase
                                  " line is to be checked again for the type attribute
                                endif
                              else
                                let s:block = 0
                                " we get here if starting and closing a block-tag on the same line
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag().
                            func! s:CheckCustomTag(ctag)
                              "{{{
                              " Returns 1 if ctag is the tag for a custom element, 0 otherwise.
                              " a:ctag can be "tag" or "/tag" or "<!--" or "-->"
                              let pattern = '\%\(\w\+-\)\+\w\+'
                              if match(a:ctag, pattern) == -1
                                return 0
                              endif
                              if matchstr(a:ctag, '\/\ze.\+') == "/"
                                " closing tag
                                if s:block != 0
                                  " ignore ctag within a block
                                  return 1
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              else
                                " opening tag
                                if s:block != 0
                                  return 1
                                endif
                                let s:nextrel += 1
                              endif
                              return 1
                            endfunc "}}}
                            
                            " Return the <script> type: either "javascript" or ""
                            func! s:GetScriptType(str)
                              "{{{
                              if a:str == "" || a:str =~ "java"
                                return "javascript"
                              else
                                return ""
                              endif
                            endfunc "}}}
                            
                            " Look back in the file, starting at a:lnum - 1, to compute a state for the
                            " start of line a:lnum.  Return the new state.
                            func! s:FreshState(lnum)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
                              let state = {}
                              let state.lnum = prevnonblank(a:lnum - 1)
                              let state.scripttype = ""
                              let state.blocktagind = -1
                              let state.block = 0
                              let state.baseindent = 0
                              let state.blocklnr = 0
                              let state.inattr = 0
                            
                              if state.lnum == 0
                                return state
                              endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
                              let stopline2 = v:lnum + 1
                              if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
                              endif
                              let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
                              if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * shiftwidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * shiftwidth()
                                    return state
                                  endif
                                endif
                              endif
                              if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
                              endif
                            
                              " else look back for comment
                              let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
                              if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                return state
                              endif
                            
                              " else within usual HTML
                              let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
                              let comcol = stridx(text, '-->')
                              if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                " TODO check tags that follow "-->"
                                return state
                              endif
                            
                              " Check if the previous line starts with end tag.
                              let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
                              if !swendtag && text =~ '</' . s:tagname . '\s*>\s*$'
                                call cursor(state.lnum, 99999)
                                normal! F<
                                let start_lnum = HtmlIndent_FindStartTag()
                                if start_lnum > 0
                                  let state.baseindent = indent(start_lnum)
                                  if col('.') > 2
                                    " check for tags before the matching opening tag.
                                    let text = getline(start_lnum)
                                    let swendtag = match(text, '^\s*</') >= 0
                                    call s:CountITags(text[: col('.') - 2])
                                    let state.baseindent += s:nextrel * shiftwidth()
                                    if !swendtag
                                      let state.baseindent += s:curind * shiftwidth()
                                    endif
                                  endif
                                  return state
                                endif
                              endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
                              let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
                              let text = getline(state.lnum)
                              let swendtag = match(text, '^\s*</') >= 0
                              call s:CountITags(tolower(text))
                              let state.baseindent = indent(state.lnum) + s:nextrel * shiftwidth()
                              if !swendtag
                                let state.baseindent += s:curind * shiftwidth()
                              endif
                              return state
                            endfunc "}}}
                            
                            " Indent inside a <pre> block: Keep indent as-is.
                            func! s:Alien2()
                              "{{{
                              return -1
                            endfunc "}}}
                            
                            " Return the indent inside a <script> block for javascript.
                            func! s:Alien3()
                              "{{{
                              let lnum = prevnonblank(v:lnum - 1)
                              while lnum > 1 && getline(lnum) =~ '^\s*/[/*]'
                                " Skip over comments to avoid that cindent() aligns with the <script> tag
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              if lnum == b:hi_indent.blocklnr
                                " indent for the first line after <script>
                                return eval(b:hi_js1indent)
                              endif
                              if b:hi_indent.scripttype == "javascript"
                                return GetJavascriptIndent()
                              else
                                return -1
                              endif
                            endfunc "}}}
                            
                            " Return the indent inside a <style> block.
                            func! s:Alien4()
                              "{{{
                              if prevnonblank(v:lnum-1) == b:hi_indent.blocklnr
                                " indent for first content line
                                return eval(b:hi_css1indent)
                              endif
                              return s:CSSIndent()
                            endfunc "}}}
                            
                            " Indending inside a <style> block.  Returns the indent.
                            func! s:CSSIndent()
                              "{{{
                              " This handles standard CSS and also Closure stylesheets where special lines
                              " start with @.
                              " When the line starts with '*' or the previous line starts with "/*"
                              " and does not end in "*/", use C indenting to format the comment.
                              " Adopted $VIMRUNTIME/indent/css.vim
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*[*]'
                                    \ || (v:lnum > 1 && getline(v:lnum - 1) =~ '\s*/\*'
                                    \     && getline(v:lnum - 1) !~ '\*/\s*$')
                                return cindent(v:lnum)
                              endif
                            
                              let min_lnum = b:hi_indent.blocklnr
                              let prev_lnum = s:CssPrevNonComment(v:lnum - 1, min_lnum)
                              let [prev_lnum, found] = HtmlIndent_FindTagStart(prev_lnum)
                              if prev_lnum <= min_lnum
                                " Just below the <style> tag, indent for first content line after comments.
                                return eval(b:hi_css1indent)
                              endif
                            
                              " If the current line starts with "}" align with it's match.
                              if curtext =~ '^\s*}'
                                call cursor(v:lnum, 1)
                                try
                                  normal! %
                                  " Found the matching "{", align with it after skipping unfinished lines.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  return indent(align_lnum)
                                catch
                                  " can't find it, try something else, but it's most likely going to be
                                  " wrong
                                endtry
                              endif
                            
                              " add indent after {
                              let brace_counts = HtmlIndent_CountBraces(prev_lnum)
                              let extra = brace_counts.c_open * shiftwidth()
                            
                              let prev_text = getline(prev_lnum)
                              let below_end_brace = prev_text =~ '}\s*$'
                            
                              " Search back to align with the first line that's unfinished.
                              let align_lnum = s:CssFirstUnfinished(prev_lnum, min_lnum)
                            
                              " Handle continuation lines if aligning with previous line and not after a
                              " "}".
                              if extra == 0 && align_lnum == prev_lnum && !below_end_brace
                                let prev_hasfield = prev_text =~ '^\s*[a-zA-Z0-9-]\+:'
                                let prev_special = prev_text =~ '^\s*\(/\*\|@\)'
                                if curtext =~ '^\s*\(/\*\|@\)'
                                  " if the current line is not a comment or starts with @ (used by template
                                  " systems) reduce indent if previous line is a continuation line
                                  if !prev_hasfield && !prev_special
                                    let extra = -shiftwidth()
                                  endif
                                else
                                  let cur_hasfield = curtext =~ '^\s*[a-zA-Z0-9-]\+:'
                                  let prev_unfinished = s:CssUnfinished(prev_text)
                                  if prev_unfinished
                                    " Continuation line has extra indent if the previous line was not a
                                    " continuation line.
                                    let extra = shiftwidth()
                                    " Align with @if
                                    if prev_text =~ '^\s*@if '
                                      let extra = 4
                                    endif
                                  elseif cur_hasfield && !prev_hasfield && !prev_special
                                    " less indent below a continuation line
                                    let extra = -shiftwidth()
                                  endif
                                endif
                              endif
                            
                              if below_end_brace
                                " find matching {, if that line starts with @ it's not the start of a rule
                                " but something else from a template system
                                call cursor(prev_lnum, 1)
                                call search('}\s*$')
                                try
                                  normal! %
                                  " Found the matching "{", align with it.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  let special = getline(align_lnum) =~ '^\s*@'
                                catch
                                  let special = 0
                                endtry
                                if special
                                  " do not reduce indent below @{ ... }
                                  if extra < 0
                                    let extra += shiftwidth()
                                  endif
                                else
                                  let extra -= (brace_counts.c_close - (prev_text =~ '^\s*}')) * shiftwidth()
                                endif
                              endif
                            
                              " if no extra indent yet...
                              if extra == 0
                                if brace_counts.p_open > brace_counts.p_close
                                  " previous line has more ( than ): add a shiftwidth
                                  let extra = shiftwidth()
                                elseif brace_counts.p_open < brace_counts.p_close
                                  " previous line has more ) than (: subtract a shiftwidth
                                  let extra = -shiftwidth()
                                endif
                              endif
                            
                              return indent(align_lnum) + extra
                            endfunc "}}}
                            
                            " Inside <style>: Whether a line is unfinished.
                            " 	tag:
                            " 	tag: blah
                            " 	tag: blah &&
                            " 	tag: blah ||
                            func! s:CssUnfinished(text)
                              "{{{
                              return a:text =~ '\(||\|&&\|:\|\k\)\s*$'
                            endfunc "}}}
                            
                            " Search back for the first unfinished line above "lnum".
                            func! s:CssFirstUnfinished(lnum, min_lnum)
                              "{{{
                              let align_lnum = a:lnum
                              while align_lnum > a:min_lnum && s:CssUnfinished(getline(align_lnum - 1))
                                let align_lnum -= 1
                              endwhile
                              return align_lnum
                            endfunc "}}}
                            
                            " Find the non-empty line at or before "lnum" that is not a comment.
                            func! s:CssPrevNonComment(lnum, stopline)
                              "{{{
                              " caller starts from a line a:lnum + 1 that is not a comment
                              let lnum = prevnonblank(a:lnum)
                              while 1
                                let ccol = match(getline(lnum), '\*/')
                                if ccol < 0
                                  " No comment end thus it's something else.
                                  return lnum
                                endif
                                call cursor(lnum, ccol + 1)
                                " Search back for the /* that starts the comment
                                let lnum = search('/\*', 'bW', a:stopline)
                                if indent(".") == virtcol(".") - 1
                                  " The  found /* is at the start of the line. Now go back to the line
                                  " above it and again check if it is a comment.
                                  let lnum = prevnonblank(lnum - 1)
                                else
                                  " /* is after something else, thus it's not a comment line.
                                  return lnum
                                endif
                              endwhile
                            endfunc "}}}
                            
                            " Check the number of {} and () in line "lnum". Return a dict with the counts.
                            func! HtmlIndent_CountBraces(lnum)
                              "{{{
                              let brs = substitute(getline(a:lnum), '[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}()]', '', 'g')
                              let c_open = 0
                              let c_close = 0
                              let p_open = 0
                              let p_close = 0
                              for brace in split(brs, '\zs')
                                if brace == "{"
                                  let c_open += 1
                                elseif brace == "}"
                                  if c_open > 0
                                    let c_open -= 1
                                  else
                                    let c_close += 1
                                  endif
                                elseif brace == '('
                                  let p_open += 1
                                elseif brace == ')'
                                  if p_open > 0
                                    let p_open -= 1
                                  else
                                    let p_close += 1
                                  endif
                                endif
                              endfor
                              return {'c_open': c_open,
                                    \ 'c_close': c_close,
                                    \ 'p_open': p_open,
                                    \ 'p_close': p_close}
                            endfunc "}}}
                            
                            " Return the indent for a comment: <!-- -->
                            func! s:Alien5()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*\zs-->'
                                " current line starts with end of comment, line up with comment start.
                                call cursor(v:lnum, 0)
                                let lnum = search('<!--', 'b')
                                if lnum > 0
                                  " TODO: what if <!-- is not at the start of the line?
                                  return indent(lnum)
                                endif
                            
                                " Strange, can't find it.
                                return -1
                              endif
                            
                              let prevlnum = prevnonblank(v:lnum - 1)
                              let prevtext = getline(prevlnum)
                              let idx = match(prevtext, '^\s*\zs<!--')
                              if idx >= 0
                                " just below comment start, add a shiftwidth
                                return idx + shiftwidth()
                              endif
                            
                              " Some files add 4 spaces just below a TODO line.  It's difficult to detect
                              " the end of the TODO, so let's not do that.
                            
                              " Align with the previous non-blank line.
                              return indent(prevlnum)
                            endfunc "}}}
                            
                            " Return the indent for conditional comment: <!--[ ![endif]-->
                            func! s:Alien6()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '\s*\zs<!\[endif\]-->'
                                " current line starts with end of comment, line up with comment start.
                                let lnum = search('<!--', 'bn')
                                if lnum > 0
                                  return indent(lnum)
                                endif
                              endif
                              return b:hi_indent.baseindent + shiftwidth()
                            endfunc "}}}
                            
                            " When the "lnum" line ends in ">" find the line containing the matching "<".
                            func! HtmlIndent_FindTagStart(lnum)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
                              let idx = match(getline(a:lnum), '\S>\s*$')
                              if idx > 0
                                call cursor(a:lnum, idx)
                                let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
                                if lnum > 0
                                  return [lnum, 1]
                                endif
                              endif
                              return [a:lnum, 0]
                            endfunc "}}}
                            
                            " Find the unclosed start tag from the current cursor position.
                            func! HtmlIndent_FindStartTag()
                              "{{{
                              " The cursor must be on or before a closing tag.
                              " If found, positions the cursor at the match and returns the line number.
                              " Otherwise returns 0.
                              let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs' . s:tagname . '\ze')
                              let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
                              if start_lnum > 0
                                return start_lnum
                              endif
                              return 0
                            endfunc "}}}
                            
                            " Moves the cursor from a "<" to the matching ">".
                            func! HtmlIndent_FindTagEnd()
                              "{{{
                              " Call this with the cursor on the "<" of a start tag.
                              " This will move the cursor to the ">" of the matching end tag or, when it's
                              " a self-closing tag, to the matching ">".
                              " Limited to look up to b:html_indent_line_limit lines away.
                              let text = getline('.')
                              let tagname = matchstr(text, s:tagname . '\|!--', col('.'))
                              if tagname == '!--'
                                call search('--\zs>')
                              elseif s:get_tag('/' . tagname) != 0
                                " tag with a closing tag, find matching "</tag>"
                                call searchpair('<' . tagname, '', '</' . tagname . '\zs>', 'W', '', line('.') + b:html_indent_line_limit)
                              else
                                " self-closing tag, find the ">"
                                call search('\S\zs>')
                              endif
                            endfunc "}}}
                            
                            " Indenting inside a start tag. Return the correct indent or -1 if unknown.
                            func! s:InsideTag(foundHtmlString)
                              "{{{
                              if a:foundHtmlString
                                " Inside an attribute string.
                                " Align with the previous line or use an external function.
                                let lnum = v:lnum - 1
                                if lnum > 1
                                  if exists('b:html_indent_tag_string_func')
                                    return b:html_indent_tag_string_func(lnum)
                                  endif
                                  return indent(lnum)
                                endif
                              endif
                            
                              " Should be another attribute: " attr="val".  Align with the previous
                              " attribute start.
                              let lnum = v:lnum
                              while lnum > 1
                                let lnum -= 1
                                let text = getline(lnum)
                                " Find a match with one of these, align with "attr":
                                "       attr=
                                "  <tag attr=
                                "  text<tag attr=
                                "  <tag>text</tag>text<tag attr=
                                " For long lines search for the first match, finding the last match
                                " gets very slow.
                                if len(text) < 300
                                  let idx = match(text, '.*\s\zs[_a-zA-Z0-9-]\+="')
                                else
                                  let idx = match(text, '\s\zs[_a-zA-Z0-9-]\+="')
                                endif
                                if idx == -1
                                  " try <tag attr
                                  let idx = match(text, '<' . s:tagname . '\s\+\zs\w')
                                endif
                                if idx == -1
                                  " after just <tag indent one level more
                                  let idx = match(text, '<' . s:tagname . '$')
                                  if idx >= 0
                            	call cursor(lnum, idx)
                            	return virtcol('.') + shiftwidth()
                                  endif
                                endif
                                if idx > 0
                                  " Found the attribute to align with.
                                  call cursor(lnum, idx)
                                  return virtcol('.')
                                endif
                              endwhile
                              return -1
                            endfunc "}}}
                            
                            " THE MAIN INDENT FUNCTION. Return the amount of indent for v:lnum.
                            func! HtmlIndent()
                              "{{{
                              if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
                              endif
                            
                              let curtext = tolower(getline(v:lnum))
                              let indentunit = shiftwidth()
                            
                              let b:hi_newstate = {}
                              let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
                              if curtext !~ '^\s*<'
                                normal! ^
                                let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
                                let foundHtmlString = 0
                                for synid in reverse(stack)
                                  let name = synIDattr(synid, "name")
                                  if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
                                endfor
                              endif
                            
                              " does the line start with a closing tag?
                              let swendtag = match(curtext, '^\s*</') >= 0
                            
                              if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
                              else
                                " start over (know nothing)
                                let b:hi_indent = s:FreshState(v:lnum)
                              endif
                            
                              if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
                              else
                                " not within a block - within usual html
                                let b:hi_newstate.block = b:hi_indent.block
                                if swendtag
                                  " The current line starts with an end tag, align with its start tag.
                                  call cursor(v:lnum, 1)
                                  let start_lnum = HtmlIndent_FindStartTag()
                                  if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
                                    let text = getline(start_lnum)
                                    let angle = matchstr(text, '[<>]')
                                    if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
                                    let indent = indent(start_lnum)
                                    if col('.') > 2
                                      let swendtag = match(text, '^\s*</') >= 0
                                      call s:CountITags(text[: col('.') - 2])
                                      let indent += s:nextrel * shiftwidth()
                                      if !swendtag
                                        let indent += s:curind * shiftwidth()
                                      endif
                                    endif
                                  else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
                                  let b:hi_newstate.baseindent = indent
                                else
                                  call s:CountTagsAndState(curtext)
                                  let indent = b:hi_indent.baseindent
                                  let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
                                endif
                              endif
                            
                              let b:hi_lasttick = b:changedtick
                              call extend(b:hi_indent, b:hi_newstate, "force")
                              return indent
                            endfunc "}}}
                            
                            " Check user settings when loading this script the first time.
                            call HtmlIndent_CheckUserSettings()
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: fdm=marker ts=8 sw=2 tw=78

SCRIPT  /usr/share/vim/vim81/syntax/eruby.vim
Sourced 1 time
Total time:   1.902693
 Self time:   0.000559

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		eRuby
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            
    1              0.000003 if exists("b:current_syntax")
                              finish
                            endif
                            
    1              0.000001 if !exists("main_syntax")
    1              0.000003   let main_syntax = 'eruby'
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:eruby_default_subtype")
                              let g:eruby_default_subtype = "html"
                            endif
                            
    1              0.000009 if &filetype =~ '^eruby\.'
                              let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
                            elseif !exists("b:eruby_subtype") && main_syntax == 'eruby'
                              let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
                              let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
                              if b:eruby_subtype == ''
                                let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\)\+$','',''),'\.\zs\w\+\%(\ze+\w\+\)\=$')
                              endif
                              if b:eruby_subtype == 'rhtml'
                                let b:eruby_subtype = 'html'
                              elseif b:eruby_subtype == 'rb'
                                let b:eruby_subtype = 'ruby'
                              elseif b:eruby_subtype == 'yml'
                                let b:eruby_subtype = 'yaml'
                              elseif b:eruby_subtype == 'js'
                                let b:eruby_subtype = 'javascript'
                              elseif b:eruby_subtype == 'txt'
                                " Conventional; not a real file type
                                let b:eruby_subtype = 'text'
                              elseif b:eruby_subtype == ''
                                let b:eruby_subtype = g:eruby_default_subtype
                              endif
                            endif
                            
    1              0.000002 if !exists("b:eruby_nest_level")
    1              0.000022   let b:eruby_nest_level = strlen(substitute(substitute(substitute(expand("%:t"),'@','','g'),'\c\.\%(erb\|rhtml\)\>','@','g'),'[^@]','','g'))
    1              0.000001 endif
    1              0.000001 if !b:eruby_nest_level
                              let b:eruby_nest_level = 1
                            endif
                            
    1              0.000002 if exists("b:eruby_subtype") && b:eruby_subtype != ''
    1   1.897205   0.000185   exe "runtime! syntax/".b:eruby_subtype.".vim"
    1              0.000002   unlet! b:current_syntax
    1              0.000001 endif
    1   0.005311   0.000197 syn include @rubyTop syntax/ruby.vim
                            
    1              0.000007 syn cluster erubyRegions contains=erubyOneLiner,erubyBlock,erubyExpression,erubyComment
                            
    1              0.000016 exe 'syn region  erubyOneLiner   matchgroup=erubyDelimiter start="^%\{1,'.b:eruby_nest_level.'\}%\@!"    end="$"     contains=@rubyTop	     containedin=ALLBUT,@erubyRegions keepend oneline'
    1              0.000012 exe 'syn region  erubyBlock      matchgroup=erubyDelimiter start="<%\{1,'.b:eruby_nest_level.'\}%\@!-\=" end="[=-]\=%\@<!%\{1,'.b:eruby_nest_level.'\}>" contains=@rubyTop  containedin=ALLBUT,@erubyRegions keepend'
    1              0.000011 exe 'syn region  erubyExpression matchgroup=erubyDelimiter start="<%\{1,'.b:eruby_nest_level.'\}=\{1,4}" end="[=-]\=%\@<!%\{1,'.b:eruby_nest_level.'\}>" contains=@rubyTop  containedin=ALLBUT,@erubyRegions keepend'
    1              0.000022 exe 'syn region  erubyComment    matchgroup=erubyDelimiter start="<%\{1,'.b:eruby_nest_level.'\}-\=#"    end="[=-]\=%\@<!%\{1,'.b:eruby_nest_level.'\}>" contains=rubyTodo,@Spell containedin=ALLBUT,@erubyRegions keepend'
                            
                            " Define the default highlighting.
                            
    1              0.000007 hi def link erubyDelimiter		PreProc
    1              0.000006 hi def link erubyComment		Comment
                            
    1              0.000002 let b:current_syntax = 'eruby'
                            
    1              0.000001 if main_syntax == 'eruby'
    1              0.000001   unlet main_syntax
    1              0.000000 endif
                            
                            " vim: nowrap sw=2 sts=2 ts=8:

SCRIPT  /usr/share/vim/vim81/syntax/html.vim
Sourced 1 time
Total time:   1.897016
 Self time:   0.004937

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Maintainer:           Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2018 May 31
                            " Included patch from Jay Sitter to add WAI-ARIA htmlArg keywords
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    1              0.000002 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
                            endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000001 syntax spell toplevel
                            
    1              0.000001 syn case ignore
                            
                            " mark illegal characters
    1              0.000015 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000018 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000014 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000012 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000013 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    1              0.000033 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000017 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000013 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000005 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000006 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000005 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000006 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000004 syn keyword htmlTagName contained form hr html img
    1              0.000005 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000005 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000005 syn keyword htmlTagName contained select small sub sup
    1              0.000013 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000008 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000005 syn keyword htmlTagName contained abbr acronym bdo button col label
    1              0.000005 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    1              0.000006 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    1              0.000005 syn keyword htmlTagName contained article aside audio bdi canvas data
    1              0.000005 syn keyword htmlTagName contained datalist details embed figcaption figure
    1              0.000005 syn keyword htmlTagName contained footer header hgroup keygen main mark
    1              0.000004 syn keyword htmlTagName contained menuitem meter nav output picture
    1              0.000005 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    1              0.000005 syn keyword htmlTagName contained slot source template time track video wbr
                            
                            " legal arg names
    1              0.000004 syn keyword htmlArg contained action
    1              0.000004 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000004 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000006 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000005 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000004 syn keyword htmlArg contained gutter height hspace id
    1              0.000003 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000005 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000005 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000004 syn keyword htmlArg contained size src start target text type url
    1              0.000005 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000006 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    1              0.000007 syn match htmlArg contained "\<\(aria-activedescendant\|aria-atomic\)\>"
    1              0.000008 syn match htmlArg contained "\<\(aria-autocomplete\|aria-busy\|aria-checked\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-colcount\|aria-colindex\|aria-colspan\)\>"
    1              0.000007 syn match htmlArg contained "\<\(aria-controls\|aria-current\)\>"
    1              0.000009 syn match htmlArg contained "\<\(aria-describedby\|aria-details\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-disabled\|aria-dropeffect\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-errormessage\|aria-expanded\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-flowto\|aria-grabbed\|aria-haspopup\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-hidden\|aria-invalid\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-keyshortcuts\|aria-label\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-labelledby\|aria-level\|aria-live\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-modal\|aria-multiline\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-multiselectable\|aria-orientation\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-owns\|aria-placeholder\|aria-posinset\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-pressed\|aria-readonly\|aria-relevant\)\>"
    1              0.000007 syn match htmlArg contained "\<\(aria-required\|aria-roledescription\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-rowcount\|aria-rowindex\|aria-rowspan\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-selected\|aria-setsize\|aria-sort\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-valuemax\|aria-valuemin\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-valuenow\|aria-valuetext\)\>"
    1              0.000004 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    1              0.000004 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000009 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000022 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    1              0.000014 syn keyword htmlArg     contained left top visibility clip id noshade
    1              0.000005 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000005 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000006 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    1              0.000016 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000012 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000012 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000013 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000008 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000004 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000004 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    1              0.000004 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    1              0.000004 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    1              0.000004 syn keyword htmlArg contained controls crossorigin default dialog dirname
    1              0.000004 syn keyword htmlArg contained download draggable dropzone form formaction
    1              0.000004 syn keyword htmlArg contained formenctype formmethod formnovalidate formtarget
    1              0.000004 syn keyword htmlArg contained hidden high icon inputmode keytype kind list loop
    1              0.000004 syn keyword htmlArg contained low max min minlength muted nonce novalidate open
    1              0.000004 syn keyword htmlArg contained optimum pattern placeholder poster preload
    1              0.000004 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    1              0.000005 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    1              0.000003 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    1              0.000007 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000004 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+ contains=@Spell
                            else
    1              0.000016   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError,@Spell
    1              0.000008   syn match  htmlCommentError contained "[^><!]"
    1              0.000008   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc,@Spell
    1              0.000001 endif
    1              0.000006 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
    1              0.000017 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000010 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000004 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000015 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000016 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000005 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000008 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000003 if !exists("html_no_rendering")
                              " rendering
    1              0.000030   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000008   syn region htmlStrike start="<del\>" end="</del>"me=e-6 contains=@htmlTop
    1              0.000006   syn region htmlStrike start="<strike\>" end="</strike>"me=e-9 contains=@htmlTop
                            
    1              0.000016   syn region htmlBold start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000014   syn region htmlBold start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000010   syn region htmlBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000009   syn region htmlBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000010   syn region htmlBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000009   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    1              0.000006   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    1              0.000009   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000011   syn region htmlUnderline start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000009   syn region htmlUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000011   syn region htmlUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000009   syn region htmlUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000008   syn region htmlUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000006   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
    1              0.000010   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
                            
    1              0.000012   syn region htmlItalic start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000005   syn region htmlItalic start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    1              0.000009   syn region htmlItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000013   syn region htmlItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000006   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop
    1              0.000008   syn region htmlItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000006   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    1              0.000006   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
                            
    1              0.000009   syn match htmlLeadingSpace "^\s\+" contained
    1              0.000033   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    1              0.000006   syn region htmlH1 start="<h1\>" end="</h1>"me=e-5 contains=@htmlTop
    1              0.000006   syn region htmlH2 start="<h2\>" end="</h2>"me=e-5 contains=@htmlTop
    1              0.000006   syn region htmlH3 start="<h3\>" end="</h3>"me=e-5 contains=@htmlTop
    1              0.000011   syn region htmlH4 start="<h4\>" end="</h4>"me=e-5 contains=@htmlTop
    1              0.000007   syn region htmlH5 start="<h5\>" end="</h5>"me=e-5 contains=@htmlTop
    1              0.000005   syn region htmlH6 start="<h6\>" end="</h6>"me=e-5 contains=@htmlTop
    1              0.000046   syn region htmlHead start="<head\>" end="</head>"me=e-7 end="<body\>"me=e-5 end="<h[1-6]\>"me=e-3 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000031   syn region htmlTitle start="<title\>" end="</title>"me=e-8 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000000 endif
                            
    1              0.000004 syn keyword htmlTagName         contained noscript
    1              0.000003 syn keyword htmlSpecialTagName  contained script style
    1              0.000003 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    1   0.000808   0.000198   syn include @htmlJavaScript syntax/javascript.vim
    1              0.000002   unlet b:current_syntax
    1              0.000018   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000035   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    1              0.000005   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    1              0.000003   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
    1              0.000009     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    1              0.000009     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    1              0.000001   endif
    1              0.000006   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    1              0.000006   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    1              0.000004   hi def link htmlEventSQ htmlEvent
    1              0.000004   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    1              0.000016   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000002 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    1   0.002659   0.000169   syn include @htmlVbScript syntax/vb.vim
    1              0.000002   unlet b:current_syntax
    1              0.000020   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000003 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    1              0.000003 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    1              0.000005   syn keyword htmlArg           contained media
    1   1.889223   0.000244   syn include @htmlCss syntax/css.vim
    1              0.000002   unlet b:current_syntax
    1              0.000031   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    1              0.000007   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    1              0.002531   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    1              0.000005   hi def link htmlStyleArg htmlString
    1              0.000001 endif
                            
    1              0.000002 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
                            endif
                            
                            " The default highlighting.
    1              0.000010 hi def link htmlTag                     Function
    1              0.000007 hi def link htmlEndTag                  Identifier
    1              0.000006 hi def link htmlArg                     Type
    1              0.000004 hi def link htmlTagName                 htmlStatement
    1              0.000006 hi def link htmlSpecialTagName          Exception
    1              0.000006 hi def link htmlValue                     String
    1              0.000007 hi def link htmlSpecialChar             Special
                            
    1              0.000003 if !exists("html_no_rendering")
    1              0.000007   hi def link htmlH1                      Title
    1              0.000005   hi def link htmlH2                      htmlH1
    1              0.000004   hi def link htmlH3                      htmlH2
    1              0.000003   hi def link htmlH4                      htmlH3
    1              0.000004   hi def link htmlH5                      htmlH4
    1              0.000004   hi def link htmlH6                      htmlH5
    1              0.000006   hi def link htmlHead                    PreProc
    1              0.000006   hi def link htmlTitle                   Title
    1              0.000005   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    1              0.000004   hi def link htmlUnderlineBold           htmlBoldUnderline
    1              0.000006   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    1              0.000004   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    1              0.000004   hi def link htmlItalicUnderline         htmlUnderlineItalic
    1              0.000004   hi def link htmlItalicBold              htmlBoldItalic
    1              0.000004   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    1              0.000004   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    1              0.000007   hi def link htmlLink                    Underlined
    1              0.000006   hi def link htmlLeadingSpace            None
    1              0.000002   if !exists("html_my_rendering")
    1              0.000004     hi def htmlBold                term=bold cterm=bold gui=bold
    1              0.000003     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000002     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000003     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000002     hi def htmlUnderline           term=underline cterm=underline gui=underline
    1              0.000003     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000003     hi def htmlItalic              term=italic cterm=italic gui=italic
    1              0.000002     if v:version > 800 || v:version == 800 && has("patch1038")
    1              0.000003         hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
    1              0.000001     else
                                    hi def htmlStrike              term=underline cterm=underline gui=underline
                                endif
    1              0.000000   endif
    1              0.000001 endif
                            
    1              0.000007 hi def link htmlPreStmt            PreProc
    1              0.000007 hi def link htmlPreError           Error
    1              0.000007 hi def link htmlPreProc            PreProc
    1              0.000007 hi def link htmlPreAttr            String
    1              0.000006 hi def link htmlPreProcAttrName    PreProc
    1              0.000007 hi def link htmlPreProcAttrError   Error
    1              0.000005 hi def link htmlSpecial            Special
    1              0.000007 hi def link htmlSpecialChar        Special
    1              0.000006 hi def link htmlString             String
    1              0.000006 hi def link htmlStatement          Statement
    1              0.000006 hi def link htmlComment            Comment
    1              0.000007 hi def link htmlCommentPart        Comment
    1              0.000006 hi def link htmlValue              String
    1              0.000005 hi def link htmlCommentError       htmlError
    1              0.000004 hi def link htmlTagError           htmlError
    1              0.000005 hi def link htmlEvent              javaScript
    1              0.000006 hi def link htmlError              Error
                            
    1              0.000007 hi def link javaScript             Special
    1              0.000005 hi def link javaScriptExpression   javaScript
    1              0.000006 hi def link htmlCssStyleComment    Comment
    1              0.000006 hi def link htmlCssDefinition      Special
                            
    1              0.000002 let b:current_syntax = "html"
                            
    1              0.000002 if main_syntax == 'html'
                              unlet main_syntax
                            endif
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim81/syntax/javascript.vim
Sourced 1 time
Total time:   0.000606
 Self time:   0.000606

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2018 Jul 28
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    1              0.000003 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
                            
    1              0.000006 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    1              0.000012 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    1              0.000007 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    1              0.000013 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    1              0.000006 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    1              0.000014 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000020 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000016 syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
    1              0.000008 syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
    1              0.000005 syn match   javaScriptSpecialCharacter "'\\.'"
    1              0.000007 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    1              0.000029 syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
    1              0.000005 syn keyword javaScriptConditional	if else switch
    1              0.000004 syn keyword javaScriptRepeat		while for do in
    1              0.000003 syn keyword javaScriptBranch		break continue
    1              0.000004 syn keyword javaScriptOperator		new delete instanceof typeof
    1              0.000006 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    1              0.000003 syn keyword javaScriptStatement		return with
    1              0.000003 syn keyword javaScriptBoolean		true false
    1              0.000004 syn keyword javaScriptNull		null undefined
    1              0.000004 syn keyword javaScriptIdentifier	arguments this var let
    1              0.000003 syn keyword javaScriptLabel		case default
    1              0.000004 syn keyword javaScriptException		try catch finally throw
    1              0.000004 syn keyword javaScriptMessage		alert confirm prompt status
    1              0.000005 syn keyword javaScriptGlobal		self window top parent
    1              0.000004 syn keyword javaScriptMember		document event location 
    1              0.000004 syn keyword javaScriptDeprecated	escape unescape
    1              0.000012 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
    1              0.000022 syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
    1              0.000003 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
    1              0.000005     syn keyword javaScriptFunction	function
    1              0.000006     syn match	javaScriptBraces	   "[{}\[\]]"
    1              0.000005     syn match	javaScriptParens	   "[()]"
    1              0.000000 endif
                            
    1              0.000001 syn sync fromstart
    1              0.000001 syn sync maxlines=100
                            
    1              0.000002 if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    1              0.000010 hi def link javaScriptComment		Comment
    1              0.000008 hi def link javaScriptLineComment		Comment
    1              0.000007 hi def link javaScriptCommentTodo		Todo
    1              0.000007 hi def link javaScriptSpecial		Special
    1              0.000007 hi def link javaScriptStringS		String
    1              0.000006 hi def link javaScriptStringD		String
    1              0.000007 hi def link javaScriptStringT		String
    1              0.000007 hi def link javaScriptCharacter		Character
    1              0.000004 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    1              0.000004 hi def link javaScriptNumber		javaScriptValue
    1              0.000023 hi def link javaScriptConditional		Conditional
    1              0.000008 hi def link javaScriptRepeat		Repeat
    1              0.000007 hi def link javaScriptBranch		Conditional
    1              0.000015 hi def link javaScriptOperator		Operator
    1              0.000007 hi def link javaScriptType			Type
    1              0.000007 hi def link javaScriptStatement		Statement
    1              0.000006 hi def link javaScriptFunction		Function
    1              0.000007 hi def link javaScriptBraces		Function
    1              0.000006 hi def link javaScriptError		Error
    1              0.000004 hi def link javaScrParenError		javaScriptError
    1              0.000006 hi def link javaScriptNull			Keyword
    1              0.000007 hi def link javaScriptBoolean		Boolean
    1              0.000006 hi def link javaScriptRegexpString		String
                            
    1              0.000006 hi def link javaScriptIdentifier		Identifier
    1              0.000006 hi def link javaScriptLabel		Label
    1              0.000007 hi def link javaScriptException		Exception
    1              0.000006 hi def link javaScriptMessage		Keyword
    1              0.000006 hi def link javaScriptGlobal		Keyword
    1              0.000007 hi def link javaScriptMember		Keyword
    1              0.000006 hi def link javaScriptDeprecated		Exception 
    1              0.000007 hi def link javaScriptReserved		Keyword
    1              0.000006 hi def link javaScriptDebug		Debug
    1              0.000006 hi def link javaScriptConstant		Label
    1              0.000007 hi def link javaScriptEmbed		Special
                            
                            
                            
    1              0.000003 let b:current_syntax = "javascript"
    1              0.000001 if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
    1              0.000007 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim81/syntax/vb.vim
Sourced 1 time
Total time:   0.002480
 Self time:   0.002480

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    1              0.000004 if exists("b:current_syntax")
                            	finish
                            endif
                            
                            " VB is case insensitive
    1              0.000001 syn case ignore
                            
    1              0.000007 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    1              0.000005 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    1              0.000004 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    1              0.000005 syn match vbOperator "[()+.,\-/*=&]"
    1              0.000004 syn match vbOperator "[<>]=\="
    1              0.000003 syn match vbOperator "<>"
    1              0.000005 syn match vbOperator "\s\+_$"
                            
    1              0.000003 syn keyword vbBoolean  True False
    1              0.000003 syn keyword vbConst Null Nothing
                            
    1              0.000003 syn keyword vbRepeat Do For ForEach Loop Next
    1              0.000004 syn keyword vbRepeat Step To Until Wend While
                            
    1              0.000004 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    1              0.000003 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    1              0.000004 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    1              0.000003 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    1              0.000003 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    1              0.000003 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    1              0.000004 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    1              0.000003 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    1              0.000003 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    1              0.000004 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    1              0.000003 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    1              0.000003 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    1              0.000003 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    1              0.000003 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    1              0.000004 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    1              0.000003 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    1              0.000004 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    1              0.000004 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    1              0.000004 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    1              0.000003 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    1              0.000004 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    1              0.000003 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    1              0.000003 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    1              0.000003 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    1              0.000003 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    1              0.000003 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    1              0.000004 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    1              0.000003 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    1              0.000003 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    1              0.000003 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    1              0.000004 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    1              0.000004 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    1              0.000004 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    1              0.000003 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    1              0.000004 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    1              0.000003 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    1              0.000003 syn keyword vbEvents IniProperties InitProperties Initialize
    1              0.000004 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    1              0.000003 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    1              0.000004 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    1              0.000003 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    1              0.000004 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    1              0.000003 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    1              0.000004 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    1              0.000003 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    1              0.000006 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    1              0.000004 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    1              0.000003 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    1              0.000003 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    1              0.000004 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    1              0.000003 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    1              0.000003 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    1              0.000003 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    1              0.000004 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    1              0.000003 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    1              0.000003 syn keyword vbEvents RepeatedControlUnloaded Reposition
    1              0.000003 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    1              0.000003 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    1              0.000004 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    1              0.000003 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    1              0.000004 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    1              0.000004 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    1              0.000003 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    1              0.000004 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    1              0.000003 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    1              0.000004 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    1              0.000003 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    1              0.000004 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    1              0.000003 syn keyword vbEvents UserEvent Validate ValidationError
    1              0.000003 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    1              0.000003 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    1              0.000003 syn keyword vbEvents WriteProperties
                            
                            
    1              0.000005 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    1              0.000005 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    1              0.000005 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    1              0.000005 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    1              0.000004 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    1              0.000004 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    1              0.000004 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    1              0.000004 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    1              0.000004 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    1              0.000003 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    1              0.000004 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    1              0.000004 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    1              0.000004 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    1              0.000072 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    1              0.000051 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    1              0.000054 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    1              0.000078 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    1              0.000070 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    1              0.000086 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    1              0.000062 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    1              0.000038 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    1              0.000045 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    1              0.000060 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    1              0.000012 syn keyword vbFunction Year
                            
    1              0.000038 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    1              0.000030 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    1              0.000037 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    1              0.000029 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    1              0.000047 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    1              0.000029 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    1              0.000030 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    1              0.000037 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    1              0.000038 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    1              0.000038 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    1              0.000030 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    1              0.000041 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    1              0.000030 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    1              0.000029 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    1              0.000038 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    1              0.000029 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    1              0.000030 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    1              0.000029 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    1              0.000030 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    1              0.000030 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    1              0.000029 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    1              0.000005 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    1              0.000004 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    1              0.000004 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    1              0.000004 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    1              0.000004 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    1              0.000004 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    1              0.000003 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    1              0.000004 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    1              0.000004 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    1              0.000004 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    1              0.000003 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    1              0.000003 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    1              0.000004 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    1              0.000004 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    1              0.000003 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    1              0.000004 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    1              0.000003 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    1              0.000004 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    1              0.000004 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    1              0.000004 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    1              0.000003 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    1              0.000004 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    1              0.000003 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    1              0.000004 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    1              0.000004 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    1              0.000003 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    1              0.000004 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    1              0.000004 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    1              0.000003 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    1              0.000004 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    1              0.000003 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    1              0.000004 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    1              0.000003 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    1              0.000004 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    1              0.000004 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    1              0.000003 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    1              0.000004 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    1              0.000003 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    1              0.000004 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    1              0.000003 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    1              0.000004 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    1              0.000004 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    1              0.000004 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    1              0.000005 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    1              0.000003 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    1              0.000004 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    1              0.000004 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    1              0.000004 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    1              0.000004 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    1              0.000003 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    1              0.000003 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    1              0.000005 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    1              0.000004 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    1              0.000003 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    1              0.000003 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    1              0.000005 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    1              0.000004 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    1              0.000004 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    1              0.000005 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    1              0.000005 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    1              0.000004 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    1              0.000005 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    1              0.000004 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    1              0.000004 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    1              0.000004 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    1              0.000004 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    1              0.000004 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    1              0.000005 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    1              0.000002 syn keyword vbStatement Write
                            
    1              0.000005 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    1              0.000005 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    1              0.000004 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    1              0.000003 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    1              0.000004 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    1              0.000004 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    1              0.000003 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
    1              0.000004 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    1              0.000004 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    1              0.000004 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    1              0.000004 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    1              0.000004 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    1              0.000004 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    1              0.000003 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    1              0.000004 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    1              0.000004 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    1              0.000003 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    1              0.000003 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    1              0.000004 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    1              0.000004 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    1              0.000003 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    1              0.000004 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    1              0.000003 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    1              0.000004 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    1              0.000003 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    1              0.000004 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    1              0.000003 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    1              0.000004 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    1              0.000003 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    1              0.000004 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    1              0.000003 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    1              0.000004 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    1              0.000003 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    1              0.000003 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    1              0.000003 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    1              0.000003 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    1              0.000003 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    1              0.000003 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    1              0.000004 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    1              0.000003 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    1              0.000004 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    1              0.000003 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    1              0.000004 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    1              0.000005 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    1              0.000004 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    1              0.000003 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    1              0.000004 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    1              0.000004 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    1              0.000004 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    1              0.000004 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    1              0.000003 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    1              0.000004 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    1              0.000003 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    1              0.000003 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    1              0.000003 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    1              0.000004 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    1              0.000004 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    1              0.000003 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    1              0.000004 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    1              0.000003 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    1              0.000004 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    1              0.000004 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    1              0.000003 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    1              0.000004 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    1              0.000003 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    1              0.000004 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    1              0.000003 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    1              0.000004 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    1              0.000003 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    1              0.000004 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    1              0.000003 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    1              0.000003 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    1              0.000004 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    1              0.000003 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    1              0.000003 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    1              0.000004 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    1              0.000003 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    1              0.000003 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    1              0.000005 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    1              0.000005 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    1              0.000004 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
    1              0.000006 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
    1              0.000006 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    1              0.000006 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
    1              0.000007 syn region  vbString		start=+"+  end=+"\|$+
    1              0.000010 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    1              0.000009 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    1              0.000005 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
    1              0.000011 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
    1              0.000012 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000009 hi def link vbBoolean		Boolean
    1              0.000007 hi def link vbLineNumber		Comment
    1              0.000007 hi def link vbComment		Comment
    1              0.000006 hi def link vbConditional	Conditional
    1              0.000007 hi def link vbConst			Constant
    1              0.000007 hi def link vbDefine			Constant
    1              0.000006 hi def link vbError			Error
    1              0.000006 hi def link vbFunction		Identifier
    1              0.000007 hi def link vbIdentifier		Identifier
    1              0.000006 hi def link vbNumber			Number
    1              0.000006 hi def link vbFloat			Float
    1              0.000007 hi def link vbMethods		PreProc
    1              0.000006 hi def link vbOperator		Operator
    1              0.000006 hi def link vbRepeat			Repeat
    1              0.000006 hi def link vbString			String
    1              0.000007 hi def link vbStatement		Statement
    1              0.000006 hi def link vbKeyword		Statement
    1              0.000006 hi def link vbEvents			Special
    1              0.000006 hi def link vbTodo			Todo
    1              0.000007 hi def link vbTypes			Type
    1              0.000006 hi def link vbTypeSpecifier	Type
                            
                            
    1              0.000003 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /usr/share/vim/vim81/syntax/css.vim
Sourced 1 time
Total time:   0.012793
 Self time:   0.012793

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/JulesWang/css.vim
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " Last Change:  2018 Feb. 27
                            "               cssClassName updated by Ryuichi Hayashida Jan 2016
                            
                            " quit when a syntax file was already loaded
    1              0.000003 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
                            elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
                            endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000001 syn case ignore
                            
                            " HTML4 tags
    1              0.000006 syn keyword cssTagName abbr address area a b base
    1              0.000003 syn keyword cssTagName bdo blockquote body br button
    1              0.000004 syn keyword cssTagName caption cite code col colgroup dd del
    1              0.000004 syn keyword cssTagName dfn div dl dt em fieldset form
    1              0.000004 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    1              0.000004 syn keyword cssTagName iframe input ins isindex kbd label legend li
    1              0.000004 syn keyword cssTagName link map menu meta noscript ol optgroup
    1              0.000004 syn keyword cssTagName option p param pre q s samp script small
    1              0.000004 syn keyword cssTagName span strong sub sup tbody td
    1              0.000004 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    1              0.000003 syn keyword cssTagName object svg
    1              0.000006 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    1              0.000004 syn keyword cssTagName article aside audio bdi canvas command data
    1              0.000005 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    1              0.000004 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    1              0.000003 syn keyword cssTagName output progress rt rp ruby section
    1              0.000004 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    1              0.000003 syn match cssTagName "\*"
                            
                            " selectors
    1              0.000004 syn match cssSelectorOp "[,>+~]"
    1              0.000030 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    1              0.000031 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    1              0.000013 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    1              0.000013 syn match cssClassNameDot contained '\.'
                            
    1              0.000001 try
    1              0.000006 syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
    1              0.000001 catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            endtry
                            
                            " digits
    1              0.000008 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    1              0.000007 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    1              0.000010 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\)\>" contains=cssUnitDecorators
    1              0.000007 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    1              0.000008 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    1              0.000007 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    1              0.000007 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    1              0.000006 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    1              0.000004 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    1              0.000003 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    1              0.000005 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    1              0.000006 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    1              0.000007 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    1              0.000004 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    1              0.000005 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    1              0.000004 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    1              0.000006 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    1              0.000004 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    1              0.000004 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    1              0.000003 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    1              0.000006 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    1              0.000005 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    1              0.000005 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    1              0.000007 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    1              0.000005 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    1              0.000003 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    1              0.000004 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    1              0.000005 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    1              0.000004 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    1              0.000003 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    1              0.000003 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    1              0.000004 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    1              0.000004 syn keyword cssColor contained thistle tomato turquoise violet wheat
    1              0.000002 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    1              0.000002 syn case match
    1              0.000009 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    1              0.000000 syn case ignore
                            
    1              0.000004 syn match cssImportant contained "!\s*important\>"
                            
    1              0.000014 syn match cssColor contained "\<transparent\>"
    1              0.000004 syn match cssColor contained "\<currentColor\>"
    1              0.000004 syn match cssColor contained "\<white\>"
    1              0.000007 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    1              0.000006 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    1              0.000006 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    1              0.000016 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    1              0.000021 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    1              0.000034 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    1              0.000027 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    1              0.000026 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000005 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    1              0.000004 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    1              0.000004 syn keyword cssCommonAttr contained auto none inherit all default normal
    1              0.000004 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    1              0.000009 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    1              0.000003 syn keyword cssAnimationAttr contained alternate reverse
    1              0.000004 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    1              0.000003 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    1              0.000003 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    1              0.000003 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    1              0.000007 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    1              0.000004 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    1              0.000004 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    1              0.000015 syn match cssBackgroundAttr contained "\<no-repeat\>"
    1              0.000004 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    1              0.000003 syn keyword cssBackgroundAttr contained cover contain
                            
    1              0.000007 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    1              0.000006 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    1              0.000005 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    1              0.000004 syn match cssBorderProp contained "\<box-decoration-break\>"
    1              0.000003 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    1              0.000004 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    1              0.000005 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    1              0.000003 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    1              0.000002 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    1              0.000005 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000005 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000004 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    1              0.000004 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    1              0.000003 syn keyword cssBoxAttr contained visible hidden scroll auto
    1              0.000004 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    1              0.000002 syn keyword cssColorProp contained opacity
    1              0.000004 syn match cssColorProp contained "\<color-profile\>"
    1              0.000004 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    1              0.000005 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    1              0.000002 syn keyword cssDimensionProp contained height
    1              0.000003 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    1              0.000006 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    1              0.000005 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    1              0.000002 syn keyword cssFlexibleBoxProp contained order
                            
    1              0.000004 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    1              0.000003 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    1              0.000004 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    1              0.000004 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    1              0.000024 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    1              0.000004 syn keyword cssFontAttr contained icon menu caption
    1              0.000003 syn match cssFontAttr contained "\<message-box\>"
    1              0.000004 syn match cssFontAttr contained "\<status-bar\>"
    1              0.000002 syn keyword cssFontAttr contained larger smaller
    1              0.000005 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    1              0.000004 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    1              0.000006 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    1              0.000011 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    1              0.000003 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    1              0.000002 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    1              0.000005 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    1              0.000002 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    1              0.000002 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    1              0.000003 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    1              0.000003 syn match cssFontProp contained "\<font-smooth\>"
    1              0.000004 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    1              0.000005 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    1              0.000016 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    1              0.000004 syn keyword cssMultiColumnProp contained columns
    1              0.000002 syn keyword cssMultiColumnAttr contained balance medium
    1              0.000004 syn keyword cssMultiColumnAttr contained always left right page column
    1              0.000004 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    1              0.000004 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    1              0.000004 syn match cssInteractProp contained "\<pointer-events\>"
    1              0.000004 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    1              0.000003 syn keyword cssGeneratedContentProp contained quotes crop
    1              0.000004 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    1              0.000003 syn match cssGeneratedContentProp contained "\<move-to\>"
    1              0.000003 syn match cssGeneratedContentProp contained "\<page-policy\>"
    1              0.000005 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    1              0.000003 syn match cssGridProp contained "\<grid\>"
    1              0.000017 syn match cssGridProp contained "\<grid\(-\(template\|auto\)\)\=\(-\(columns\|rows\|areas\)\)\>"
    1              0.000006 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    1              0.000003 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    1              0.000004 syn match cssGridProp contained "\<grid-auto-flow\>"
                            
    1              0.000005 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    1              0.000004 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    1              0.000005 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    1              0.000005 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    1              0.000005 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    1              0.000004 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    1              0.000002 syn keyword cssListAttr contained inside outside
                            
    1              0.000004 syn keyword cssPositioningProp contained bottom clear clip display float left
    1              0.000003 syn keyword cssPositioningProp contained position right top visibility
    1              0.000003 syn match cssPositioningProp contained "\<z-index\>"
    1              0.000003 syn keyword cssPositioningAttr contained block compact grid
    1              0.000019 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    1              0.000003 syn keyword cssPositioningAttr contained left right both
    1              0.000004 syn match cssPositioningAttr contained "\<list-item\>"
    1              0.000005 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    1              0.000003 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid
                            
    1              0.000003 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    1              0.000007 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    1              0.000004 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    1              0.000004 syn keyword cssTextProp contained color direction
    1              0.000011 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    1              0.000007 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    1              0.000004 syn match cssTextProp contained "\<word-\(break\|\wrap\)\>"
    1              0.000003 syn match cssTextProp contained "\<white-space\>"
    1              0.000004 syn match cssTextProp contained "\<hanging-punctuation\>"
    1              0.000004 syn match cssTextProp contained "\<punctuation-trim\>"
    1              0.000009 syn match cssTextAttr contained "\<line-through\>"
    1              0.000004 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    1              0.000003 syn keyword cssTextAttr contained ltr rtl embed nowrap
    1              0.000004 syn keyword cssTextAttr contained underline overline blink sub super middle
    1              0.000003 syn keyword cssTextAttr contained capitalize uppercase lowercase
    1              0.000003 syn keyword cssTextAttr contained justify baseline sub super
    1              0.000003 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed
    1              0.000003 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    1              0.000005 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    1              0.000002 syn keyword cssTextAttr contained start end adjacent
    1              0.000005 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    1              0.000003 syn keyword cssTextAttr contained distribute kashida first last
    1              0.000003 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    1              0.000004 syn match cssTextAttr contained "\<break-all\>"
    1              0.000003 syn match cssTextAttr contained "\<break-word\>"
    1              0.000002 syn keyword cssTextAttr contained hyphenate
    1              0.000003 syn match cssTextAttr contained "\<bidi-override\>"
                            
    1              0.000004 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    1              0.000005 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    1              0.000017 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    1              0.000007 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    1              0.000004 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    1              0.000004 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    1              0.000004 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    1              0.000003 syn match cssUIProp contained "\<box-sizing\>"
    1              0.000004 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    1              0.000002 syn keyword cssUIProp contained cursor
    1              0.000006 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    1              0.000003 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    1              0.000003 syn keyword cssUIAttr contained progress wait text cell move
    1              0.000003 syn match cssUIAttr contained "\<context-menu\>"
    1              0.000003 syn match cssUIAttr contained "\<no-drop\>"
    1              0.000018 syn match cssUIAttr contained "\<not-allowed\>"
    1              0.000004 syn match cssUIAttr contained "\<all-scroll\>"
    1              0.000003 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    1              0.000004 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    1              0.000003 syn match cssUIProp contained "\<ime-mode\>"
    1              0.000003 syn keyword cssUIAttr contained active inactive disabled
                            
    1              0.000005 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    1              0.000005 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    1              0.000002 syn keyword cssUIAttr contained invert
                            
    1              0.000002 syn keyword cssUIProp contained icon resize
    1              0.000002 syn keyword cssUIAttr contained both horizontal vertical
                            
    1              0.000003 syn match cssUIProp contained "\<text-overflow\>"
    1              0.000003 syn keyword cssUIAttr contained clip ellipsis
                            
    1              0.000003 syn match cssUIProp contained "\<image-rendering\>"
    1              0.000002 syn keyword cssUIAttr contained pixellated
    1              0.000003 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    1              0.000026 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    1              0.000004 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    1              0.000005 syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
    1              0.000005 syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
    1              0.000004 syn keyword cssUIProp contained appearance
    1              0.000004 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    1              0.000004 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    1              0.000009 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    1              0.000004 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    1              0.000003 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    1              0.000003 syn keyword cssAuralAttr contained silent
    1              0.000003 syn match cssAuralAttr contained "\<spell-out\>"
    1              0.000002 syn keyword cssAuralAttr contained non mix
    1              0.000004 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    1              0.000005 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    1              0.000003 syn keyword cssAuralAttr contained leftwards rightwards behind
    1              0.000003 syn keyword cssAuralAttr contained below level above lower higher
    1              0.000020 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    1              0.000003 syn keyword cssAuralAttr contained faster slower
    1              0.000004 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    1              0.000004 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    1              0.000004 syn keyword cssMediaProp contained width height orientation scan grid
    1              0.000005 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    1              0.000005 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    1              0.000005 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    1              0.000007 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    1              0.000004 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    1              0.000006 syn match cssKeyFrameProp /\d*%\|from\|to/  contained nextgroup=cssDefinition
    1              0.000010 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    1              0.000003 syn keyword cssPageProp contained content size
    1              0.000003 syn keyword cssPageProp contained orphans widows
    1              0.000002 syn keyword cssFontDescriptorProp contained src
    1              0.000004 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    1              0.000005 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    1              0.000021 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    1              0.000004 syn match cssBraces contained "[{}]"
    1              0.000004 syn match cssError contained "{@<>"
    1              0.001876 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    1              0.000004 syn match cssBraceError "}"
    1              0.000003 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    1              0.000034 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    1              0.000005 syn keyword cssPseudoClassId contained link visited active hover before after left right
    1              0.000004 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    1              0.000005 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    1              0.000005 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    1              0.000034 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")"
                            " ------------------------------------
                            " Vendor specific properties
    1              0.000004 syn match cssPseudoClassId contained  "\<selection\>"
    1              0.000004 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    1              0.000004 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    1              0.000010 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    1              0.000003 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    1              0.000006 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    1              0.000005 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    1              0.000021 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    1              0.000003 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    1              0.000015 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    1              0.000012 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    1              0.000005 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    1              0.000003 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
    1              0.002441 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    1              0.004158 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    1              0.000014 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/ contained
                            
    1              0.000005 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    1              0.000033 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment nextgroup=cssDefinition
    1              0.000007 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    1              0.000013 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    1              0.000006 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    1              0.000042 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    1              0.000040 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    1              0.000021 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    1              0.000019 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @font-face
                            " http://www.w3.org/TR/css3-fonts/#at-font-face-rule
    1              0.000008 syn match cssAtRule "@font-face\>" nextgroup=cssFontDescriptorBlock
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    1              0.001832 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    1              0.000006 if main_syntax == "css"
                              syn sync minlines=10
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000013 hi def link cssComment Comment
    1              0.000008 hi def link cssVendor Comment
    1              0.000006 hi def link cssHacks Comment
    1              0.000006 hi def link cssTagName Statement
    1              0.000006 hi def link cssDeprecated Error
    1              0.000006 hi def link cssSelectorOp Special
    1              0.000006 hi def link cssSelectorOp2 Special
    1              0.000005 hi def link cssAttrComma Special
                            
    1              0.000003 hi def link cssAnimationProp cssProp
    1              0.000003 hi def link cssBackgroundProp cssProp
    1              0.000003 hi def link cssBorderProp cssProp
    1              0.000002 hi def link cssBoxProp cssProp
    1              0.000003 hi def link cssColorProp cssProp
    1              0.000003 hi def link cssContentForPagedMediaProp cssProp
    1              0.000002 hi def link cssDimensionProp cssProp
    1              0.000003 hi def link cssFlexibleBoxProp cssProp
    1              0.000003 hi def link cssFontProp cssProp
    1              0.000002 hi def link cssGeneratedContentProp cssProp
    1              0.000003 hi def link cssGridProp cssProp
    1              0.000003 hi def link cssHyerlinkProp cssProp
    1              0.000002 hi def link cssInteractProp cssProp
    1              0.000003 hi def link cssLineboxProp cssProp
    1              0.000002 hi def link cssListProp cssProp
    1              0.000006 hi def link cssMarqueeProp cssProp
    1              0.000002 hi def link cssMultiColumnProp cssProp
    1              0.000003 hi def link cssPagedMediaProp cssProp
    1              0.000002 hi def link cssPositioningProp cssProp
    1              0.000003 hi def link cssPrintProp cssProp
    1              0.000002 hi def link cssRubyProp cssProp
    1              0.000002 hi def link cssSpeechProp cssProp
    1              0.000003 hi def link cssTableProp cssProp
    1              0.000002 hi def link cssTextProp cssProp
    1              0.000003 hi def link cssTransformProp cssProp
    1              0.000002 hi def link cssTransitionProp cssProp
    1              0.000003 hi def link cssUIProp cssProp
    1              0.000002 hi def link cssIEUIProp cssProp
    1              0.000003 hi def link cssAuralProp cssProp
    1              0.000002 hi def link cssRenderProp cssProp
    1              0.000002 hi def link cssMobileTextProp cssProp
                            
    1              0.000002 hi def link cssAnimationAttr cssAttr
    1              0.000003 hi def link cssBackgroundAttr cssAttr
    1              0.000003 hi def link cssBorderAttr cssAttr
    1              0.000002 hi def link cssBoxAttr cssAttr
    1              0.000002 hi def link cssContentForPagedMediaAttr cssAttr
    1              0.000003 hi def link cssDimensionAttr cssAttr
    1              0.000002 hi def link cssFlexibleBoxAttr cssAttr
    1              0.000003 hi def link cssFontAttr cssAttr
    1              0.000002 hi def link cssGeneratedContentAttr cssAttr
    1              0.000003 hi def link cssGridAttr cssAttr
    1              0.000002 hi def link cssHyerlinkAttr cssAttr
    1              0.000002 hi def link cssInteractAttr cssAttr
    1              0.000003 hi def link cssLineboxAttr cssAttr
    1              0.000002 hi def link cssListAttr cssAttr
    1              0.000002 hi def link cssMarginAttr cssAttr
    1              0.000002 hi def link cssMarqueeAttr cssAttr
    1              0.000003 hi def link cssMultiColumnAttr cssAttr
    1              0.000002 hi def link cssPaddingAttr cssAttr
    1              0.000002 hi def link cssPagedMediaAttr cssAttr
    1              0.000003 hi def link cssPositioningAttr cssAttr
    1              0.000002 hi def link cssGradientAttr cssAttr
    1              0.000003 hi def link cssPrintAttr cssAttr
    1              0.000002 hi def link cssRubyAttr cssAttr
    1              0.000002 hi def link cssSpeechAttr cssAttr
    1              0.000002 hi def link cssTableAttr cssAttr
    1              0.000003 hi def link cssTextAttr cssAttr
    1              0.000002 hi def link cssTransformAttr cssAttr
    1              0.000002 hi def link cssTransitionAttr cssAttr
    1              0.000003 hi def link cssUIAttr cssAttr
    1              0.000002 hi def link cssIEUIAttr cssAttr
    1              0.000003 hi def link cssAuralAttr cssAttr
    1              0.000002 hi def link cssRenderAttr cssAttr
    1              0.000002 hi def link cssCommonAttr cssAttr
                            
    1              0.000006 hi def link cssPseudoClassId PreProc
    1              0.000006 hi def link cssPseudoClassLang Constant
    1              0.000006 hi def link cssValueLength Number
    1              0.000006 hi def link cssValueInteger Number
    1              0.000007 hi def link cssValueNumber Number
    1              0.000006 hi def link cssValueAngle Number
    1              0.000006 hi def link cssValueTime Number
    1              0.000006 hi def link cssValueFrequency Number
    1              0.000006 hi def link cssFunction Constant
    1              0.000006 hi def link cssURL String
    1              0.000006 hi def link cssFunctionName Function
    1              0.000008 hi def link cssFunctionComma Function
    1              0.000006 hi def link cssColor Constant
    1              0.000007 hi def link cssIdentifier Function
    1              0.000006 hi def link cssAtRule Include
    1              0.000005 hi def link cssAtKeyword PreProc
    1              0.000007 hi def link cssImportant Special
    1              0.000006 hi def link cssBraces Function
    1              0.000005 hi def link cssBraceError Error
    1              0.000006 hi def link cssError Error
    1              0.000007 hi def link cssUnicodeEscape Special
    1              0.000006 hi def link cssStringQQ String
    1              0.000006 hi def link cssStringQ String
    1              0.000006 hi def link cssAttributeSelector String
    1              0.000006 hi def link cssMediaType Special
    1              0.000006 hi def link cssMediaComma Normal
    1              0.000006 hi def link cssAtRuleLogical Statement
    1              0.000003 hi def link cssMediaProp cssProp
    1              0.000002 hi def link cssMediaAttr cssAttr
    1              0.000006 hi def link cssPagePseudo PreProc
    1              0.000003 hi def link cssPageMarginProp cssAtKeyword
    1              0.000002 hi def link cssPageProp cssProp
    1              0.000006 hi def link cssKeyFrameProp Constant
    1              0.000006 hi def link cssFontDescriptor Special
    1              0.000003 hi def link cssFontDescriptorProp cssProp
    1              0.000002 hi def link cssFontDescriptorAttr cssAttr
    1              0.000006 hi def link cssUnicodeRange Constant
    1              0.000006 hi def link cssClassName Function
    1              0.000006 hi def link cssClassNameDot Function
    1              0.000006 hi def link cssProp StorageClass
    1              0.000006 hi def link cssAttr Constant
    1              0.000006 hi def link cssUnitDecorators Number
    1              0.000002 hi def link cssNoise Noise
                            
    1              0.000003 let b:current_syntax = "css"
                            
    1              0.000002 if main_syntax == 'css'
                              unlet main_syntax
                            endif
                            
    1              0.000012 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /home/mo/dotfiles/vim/bundle/vim-css-color/after/syntax/css.vim
Sourced 1 time
Total time:   1.876167
 Self time:   0.003153

count  total (s)   self (s)
                            " Language:     Colored CSS Color Preview
                            " Author:       Max Vasiliev <vim@skammer.name>
                            " Last Change:  2010 Jul 3
                            " Licence:      No Warranties. WTFPL. But please tell me!
                            " Version:      0.7.1
                            
    1              0.000005 function! s:StrLen(str)
                              return strlen(substitute(a:str, '.', 'x', 'g'))
                            endfunction
                            
    1              0.000001 function! s:FGforBG(bg)
                              " takes a 6hex color code and returns a matching color that is visible
                              let pure = substitute(a:bg,'^#','','')
                              let r = eval('0x'.pure[0].pure[1])
                              let g = eval('0x'.pure[2].pure[3])
                              let b = eval('0x'.pure[4].pure[5])
                              if r*30 + g*59 + b*11 > 12000
                                return '#000000'
                              else
                                return '#ffffff'
                              end
                            endfunction
                            
    1              0.000001 function! s:SetMatcher(clr,pat)
                              let group = 'cssColor'.substitute(a:clr,'^#','','')
                              redir => s:currentmatch
                              silent! exe 'syn list '.group
                              redir END
                              if s:currentmatch !~ a:pat.'\/'
                                exe 'syn match '.group.' /'.a:pat.'/ contained'
                                exe 'syn cluster cssColors add='.group
                                if has('gui_running')
                                  exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                  exe 'hi '.group.' guibg='.a:clr
                                elseif &t_Co == 256
                                  exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
                                  exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
                                endif
                                return 1
                              else
                                return 0
                              endif
                            endfunction
                            
                            "" the 6 value iterations in the xterm color cube
    1              0.000003 let s:valuerange = [ 0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF ]
                            "
                            "" 16 basic colors
    1              0.000016 let s:basic16 = [ [ 0x00, 0x00, 0x00 ], [ 0xCD, 0x00, 0x00 ], [ 0x00, 0xCD, 0x00 ], [ 0xCD, 0xCD, 0x00 ], [ 0x00, 0x00, 0xEE ], [ 0xCD, 0x00, 0xCD ], [ 0x00, 0xCD, 0xCD ], [ 0xE5, 0xE5, 0xE5 ], [ 0x7F, 0x7F, 0x7F ], [ 0xFF, 0x00, 0x00 ], [ 0x00, 0xFF, 0x00 ], [ 0xFF, 0xFF, 0x00 ], [ 0x5C, 0x5C, 0xFF ], [ 0xFF, 0x00, 0xFF ], [ 0x00, 0xFF, 0xFF ], [ 0xFF, 0xFF, 0xFF ] ]
                            :
    1              0.000002 function! s:Xterm2rgb(color)
                              " 16 basic colors
                              let r=0
                              let g=0
                              let b=0
                              if a:color<16
                                let r = s:basic16[a:color][0]
                                let g = s:basic16[a:color][1]
                                let b = s:basic16[a:color][2]
                              endif
                            
                              " color cube color
                              if a:color>=16 && a:color<=232
                                let color=a:color-16
                                let r = s:valuerange[(color/36)%6]
                                let g = s:valuerange[(color/6)%6]
                                let b = s:valuerange[color%6]
                              endif
                            
                              " gray tone
                              if a:color>=233 && a:color<=253
                                let r=8+(a:color-232)*0x0a
                                let g=r
                                let b=r
                              endif
                              let rgb=[r,g,b]
                              return rgb
                            endfunction
                            
    1              0.000001 function! s:pow(x, n)
                              let x = a:x
                              for i in range(a:n-1)
                                let x = x*a:x
                              return x
                            endfunction
                            
    1              0.000087 let s:colortable=[]
  256              0.000146 for c in range(0, 254)
  255   0.005245   0.000575   let color = s:Xterm2rgb(c)
  255              0.000315   call add(s:colortable, color)
  255              0.000117 endfor
                            
                            " selects the nearest xterm color for a rgb value like #FF0000
    1              0.000002 function! s:Rgb2xterm(color)
                              let best_match=0
                              let smallest_distance = 10000000000
                              let r = eval('0x'.a:color[1].a:color[2])
                              let g = eval('0x'.a:color[3].a:color[4])
                              let b = eval('0x'.a:color[5].a:color[6])
                              for c in range(0,254)
                                let d = s:pow(s:colortable[c][0]-r,2) + s:pow(s:colortable[c][1]-g,2) + s:pow(s:colortable[c][2]-b,2)
                                if d<smallest_distance
                                  let smallest_distance = d
                                  let best_match = c
                                endif
                              endfor
                              return best_match
                            endfunction
                            
    1              0.000002 function! s:SetNamedColor(clr,name)
                              let group = 'cssColor'.substitute(a:clr,'^#','','')
                              exe 'syn keyword '.group.' '.a:name.' contained'
                              exe 'syn cluster cssColors add='.group
                              if has('gui_running')
                                exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                exe 'hi '.group.' guibg='.a:clr
                              elseif &t_Co == 256
                                exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
                                exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
                              endif
                              return 23
                            endfunction
                            
                            " shamelessly stolen from ConvertBase.vim
                            " http://www.vim.org/scripts/script.php?script_id=54
    1              0.000002 function! s:ConvertToBase(int, base)
                              if (a:base < 2 || a:base > 36)
                                echohl ErrorMsg
                                echo "Bad base - must be between 2 and 36."
                                echohl None
                                return ''
                              endif
                            
                              if (a:int == 0)
                                return 0
                              endif
                            
                              let out=''
                            
                              let isnegative = 0
                              let int=a:int
                              if (int < 0)
                                let isnegative = 1
                                let int = - int
                              endif
                            
                              while (int != 0)
                                let out = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[(int % a:base)] . out
                                let int = int / a:base
                              endwhile
                            
                              if isnegative
                                let out = '-' . out
                              endif
                            
                              return out
                            endfunction
                            
                            " Convert 80% -> 204, 100% -> 255, etc.
                            " This piece of code was ported from lisp.
                            " http://julien.danjou.info/rainbow-mode.html
    1              0.000002 fun! s:RGBRelativeToAbsolute(value)
                              let string_length = s:StrLen(a:value)-1
                              if strpart(a:value, string_length, 1) == '%'
                                let hex_value = s:ConvertToBase(  255*strpart(a:value, 0, string_length)/100, 16 )
                                if len(hex_value) == 1
                                  return "0".hex_value
                                endif
                                return hex_value
                              else
                                let hex_value = s:ConvertToBase( a:value, 16 )
                                if len( hex_value ) == 1
                                  return "0".hex_value
                                else
                                  return hex_value
                                endif
                              endif
                            endf
                            
    1              0.000001 function! s:PreviewCSSColorInLine(where)
                              " TODO use cssColor matchdata
                              let n = 1
                              let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6\}\>' )
                              while foundcolor != ''
                                if foundcolor =~ '#\x\{6}$'
                                  let color = foundcolor
                                elseif foundcolor =~ '#\x\{3}$'
                                  let color = substitute(foundcolor, '\(\x\)\(\x\)\(\x\)', '\1\1\2\2\3\3', '')
                                else
                                  let color = ''
                                endif
                            
                                if color != ''
                                  call s:SetMatcher(color,foundcolor)
                                endif
                            
                                let n+=1
                                let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6}', 0, n )
                              endwhile
                            
                            
                              let n = 1
                              let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              while len(foundcolorlist) != 0
                                  let foundcolorlist[1] = s:RGBRelativeToAbsolute( foundcolorlist[1] )
                                  let foundcolorlist[2] = s:RGBRelativeToAbsolute( foundcolorlist[2] )
                                  let foundcolorlist[3] = s:RGBRelativeToAbsolute( foundcolorlist[3] )
                            
                                  let color = "#".join( foundcolorlist[1:3], "" )
                            
                                  call s:SetMatcher( color, foundcolorlist[0] )
                            
                                  let n+=1
                                  let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              endw
                              return 0
                            endfunction
                            
    1              0.000006 if has("gui_running") || &t_Co==256
                              " HACK modify cssDefinition to add @cssColors to its contains
    1              0.000003   redir => s:olddef
    1              0.000075   silent!  syn list cssDefinition
    1              0.000003   redir END
    1              0.000002   if s:olddef != ''
    1              0.000003     let s:b = strridx(s:olddef,'matchgroup')
    1              0.000002     if s:b != -1
    1              0.000160       exe 'syn region cssDefinition '.strpart(s:olddef,s:b).',@cssColors'
    1              0.000000     endif
    1              0.000001   endif
                            
                              " w3c Colors
    1   0.012538   0.000008   let i = s:SetNamedColor('#800000', 'maroon')
    1   0.012526   0.000008   let i = s:SetNamedColor('#ff0000', 'red')
    1   0.012625   0.000007   let i = s:SetNamedColor('#ffA500', 'orange')
    1   0.012531   0.000008   let i = s:SetNamedColor('#ffff00', 'yellow')
    1   0.012504   0.000008   let i = s:SetNamedColor('#808000', 'olive')
    1   0.012535   0.000007   let i = s:SetNamedColor('#800080', 'purple')
    1   0.012551   0.000007   let i = s:SetNamedColor('#ff00ff', 'fuchsia')
    1   0.012403   0.000007   let i = s:SetNamedColor('#ffffff', 'white')
    1   0.012480   0.000008   let i = s:SetNamedColor('#00ff00', 'lime')
    1   0.012452   0.000007   let i = s:SetNamedColor('#008000', 'green')
    1   0.012508   0.000007   let i = s:SetNamedColor('#000080', 'navy')
    1   0.011948   0.000007   let i = s:SetNamedColor('#0000ff', 'blue')
    1   0.012090   0.000008   let i = s:SetNamedColor('#00ffff', 'aqua')
    1   0.012258   0.000008   let i = s:SetNamedColor('#008080', 'teal')
    1   0.012036   0.000009   let i = s:SetNamedColor('#000000', 'black')
    1   0.012277   0.000007   let i = s:SetNamedColor('#c0c0c0', 'silver')
    1   0.012259   0.000008   let i = s:SetNamedColor('#808080', 'gray')
                            
                              " extra colors
    1   0.012282   0.000007   let i = s:SetNamedColor('#F0F8FF','AliceBlue')
    1   0.012335   0.000007   let i = s:SetNamedColor('#FAEBD7','AntiqueWhite')
    1   0.012222   0.000007   let i = s:SetNamedColor('#7FFFD4','Aquamarine')
    1   0.012381   0.000008   let i = s:SetNamedColor('#F0FFFF','Azure')
    1   0.012239   0.000007   let i = s:SetNamedColor('#F5F5DC','Beige')
    1   0.012261   0.000008   let i = s:SetNamedColor('#FFE4C4','Bisque')
    1   0.012625   0.000008   let i = s:SetNamedColor('#FFEBCD','BlanchedAlmond')
    1   0.012349   0.000018   let i = s:SetNamedColor('#8A2BE2','BlueViolet')
    1   0.012300   0.000008   let i = s:SetNamedColor('#A52A2A','Brown')
    1   0.012283   0.000008   let i = s:SetNamedColor('#DEB887','BurlyWood')
    1   0.011995   0.000007   let i = s:SetNamedColor('#5F9EA0','CadetBlue')
    1   0.012140   0.000007   let i = s:SetNamedColor('#7FFF00','Chartreuse')
    1   0.011934   0.000007   let i = s:SetNamedColor('#D2691E','Chocolate')
    1   0.012163   0.000007   let i = s:SetNamedColor('#FF7F50','Coral')
    1   0.014390   0.000008   let i = s:SetNamedColor('#6495ED','CornflowerBlue')
    1   0.012256   0.000007   let i = s:SetNamedColor('#FFF8DC','Cornsilk')
    1   0.012531   0.000009   let i = s:SetNamedColor('#DC143C','Crimson')
    1   0.012167   0.000009   let i = s:SetNamedColor('#00FFFF','Cyan')
    1   0.012011   0.000007   let i = s:SetNamedColor('#00008B','DarkBlue')
    1   0.012028   0.000017   let i = s:SetNamedColor('#008B8B','DarkCyan')
    1   0.012036   0.000008   let i = s:SetNamedColor('#B8860B','DarkGoldenRod')
    1   0.011975   0.000008   let i = s:SetNamedColor('#A9A9A9','DarkGray')
    1   0.011903   0.000007   let i = s:SetNamedColor('#A9A9A9','DarkGrey')
    1   0.011895   0.000007   let i = s:SetNamedColor('#006400','DarkGreen')
    1   0.011930   0.000007   let i = s:SetNamedColor('#BDB76B','DarkKhaki')
    1   0.012022   0.000008   let i = s:SetNamedColor('#8B008B','DarkMagenta')
    1   0.011962   0.000007   let i = s:SetNamedColor('#556B2F','DarkOliveGreen')
    1   0.012083   0.000007   let i = s:SetNamedColor('#FF8C00','Darkorange')
    1   0.011946   0.000007   let i = s:SetNamedColor('#9932CC','DarkOrchid')
    1   0.011971   0.000007   let i = s:SetNamedColor('#8B0000','DarkRed')
    1   0.011931   0.000007   let i = s:SetNamedColor('#E9967A','DarkSalmon')
    1   0.011973   0.000007   let i = s:SetNamedColor('#8FBC8F','DarkSeaGreen')
    1   0.011962   0.000006   let i = s:SetNamedColor('#483D8B','DarkSlateBlue')
    1   0.013012   0.000008   let i = s:SetNamedColor('#2F4F4F','DarkSlateGray')
    1   0.012154   0.000009   let i = s:SetNamedColor('#2F4F4F','DarkSlateGrey')
    1   0.012079   0.000007   let i = s:SetNamedColor('#00CED1','DarkTurquoise')
    1   0.012061   0.000007   let i = s:SetNamedColor('#9400D3','DarkViolet')
    1   0.012410   0.000007   let i = s:SetNamedColor('#FF1493','DeepPink')
    1   0.012044   0.000008   let i = s:SetNamedColor('#00BFFF','DeepSkyBlue')
    1   0.012099   0.000007   let i = s:SetNamedColor('#696969','DimGray')
    1   0.011999   0.000008   let i = s:SetNamedColor('#696969','DimGrey')
    1   0.012106   0.000008   let i = s:SetNamedColor('#1E90FF','DodgerBlue')
    1   0.011839   0.000007   let i = s:SetNamedColor('#B22222','FireBrick')
    1   0.011960   0.000007   let i = s:SetNamedColor('#FFFAF0','FloralWhite')
    1   0.011894   0.000007   let i = s:SetNamedColor('#228B22','ForestGreen')
    1   0.012044   0.000007   let i = s:SetNamedColor('#DCDCDC','Gainsboro')
    1   0.011991   0.000007   let i = s:SetNamedColor('#F8F8FF','GhostWhite')
    1   0.011974   0.000007   let i = s:SetNamedColor('#FFD700','Gold')
    1   0.011704   0.000006   let i = s:SetNamedColor('#DAA520','GoldenRod')
    1   0.011833   0.000008   let i = s:SetNamedColor('#808080','Grey')
    1   0.011882   0.000004   let i = s:SetNamedColor('#ADFF2F','GreenYellow')
    1   0.011831   0.000007   let i = s:SetNamedColor('#F0FFF0','HoneyDew')
    1   0.011799   0.000007   let i = s:SetNamedColor('#FF69B4','HotPink')
    1   0.011791   0.000007   let i = s:SetNamedColor('#CD5C5C','IndianRed')
    1   0.011808   0.000007   let i = s:SetNamedColor('#4B0082','Indigo')
    1   0.011800   0.000007   let i = s:SetNamedColor('#FFFFF0','Ivory')
    1   0.011812   0.000007   let i = s:SetNamedColor('#F0E68C','Khaki')
    1   0.011799   0.000007   let i = s:SetNamedColor('#E6E6FA','Lavender')
    1   0.012341   0.000007   let i = s:SetNamedColor('#FFF0F5','LavenderBlush')
    1   0.011774   0.000009   let i = s:SetNamedColor('#7CFC00','LawnGreen')
    1   0.011857   0.000009   let i = s:SetNamedColor('#FFFACD','LemonChiffon')
    1   0.011838   0.000007   let i = s:SetNamedColor('#ADD8E6','LightBlue')
    1   0.011942   0.000008   let i = s:SetNamedColor('#F08080','LightCoral')
    1   0.011786   0.000007   let i = s:SetNamedColor('#E0FFFF','LightCyan')
    1   0.011776   0.000008   let i = s:SetNamedColor('#FAFAD2','LightGoldenRodYellow')
    1   0.011752   0.000007   let i = s:SetNamedColor('#D3D3D3','LightGray')
    1   0.011824   0.000007   let i = s:SetNamedColor('#D3D3D3','LightGrey')
    1   0.011771   0.000007   let i = s:SetNamedColor('#90EE90','LightGreen')
    1   0.011726   0.000007   let i = s:SetNamedColor('#FFB6C1','LightPink')
    1   0.011690   0.000007   let i = s:SetNamedColor('#FFA07A','LightSalmon')
    1   0.011705   0.000013   let i = s:SetNamedColor('#20B2AA','LightSeaGreen')
    1   0.011768   0.000008   let i = s:SetNamedColor('#87CEFA','LightSkyBlue')
    1   0.011796   0.000007   let i = s:SetNamedColor('#778899','LightSlateGray')
    1   0.011819   0.000007   let i = s:SetNamedColor('#778899','LightSlateGrey')
    1   0.011821   0.000007   let i = s:SetNamedColor('#B0C4DE','LightSteelBlue')
    1   0.011727   0.000007   let i = s:SetNamedColor('#FFFFE0','LightYellow')
    1   0.011707   0.000007   let i = s:SetNamedColor('#32CD32','LimeGreen')
    1   0.011863   0.000007   let i = s:SetNamedColor('#FAF0E6','Linen')
    1   0.011889   0.000007   let i = s:SetNamedColor('#FF00FF','Magenta')
    1   0.012158   0.000007   let i = s:SetNamedColor('#66CDAA','MediumAquaMarine')
    1   0.011800   0.000010   let i = s:SetNamedColor('#0000CD','MediumBlue')
    1   0.011605   0.000008   let i = s:SetNamedColor('#BA55D3','MediumOrchid')
    1   0.011709   0.000008   let i = s:SetNamedColor('#9370D8','MediumPurple')
    1   0.011745   0.000008   let i = s:SetNamedColor('#3CB371','MediumSeaGreen')
    1   0.011678   0.000008   let i = s:SetNamedColor('#7B68EE','MediumSlateBlue')
    1   0.011608   0.000007   let i = s:SetNamedColor('#00FA9A','MediumSpringGreen')
    1   0.011715   0.000007   let i = s:SetNamedColor('#48D1CC','MediumTurquoise')
    1   0.011631   0.000007   let i = s:SetNamedColor('#C71585','MediumVioletRed')
    1   0.011619   0.000007   let i = s:SetNamedColor('#191970','MidnightBlue')
    1   0.012160   0.000007   let i = s:SetNamedColor('#F5FFFA','MintCream')
    1   0.011713   0.000010   let i = s:SetNamedColor('#FFE4E1','MistyRose')
    1   0.011615   0.000007   let i = s:SetNamedColor('#FFE4B5','Moccasin')
    1   0.011933   0.000009   let i = s:SetNamedColor('#FFDEAD','NavajoWhite')
    1   0.012469   0.000013   let i = s:SetNamedColor('#FDF5E6','OldLace')
    1   0.016774   0.000040   let i = s:SetNamedColor('#6B8E23','OliveDrab')
    1   0.011976   0.000011   let i = s:SetNamedColor('#FF4500','OrangeRed')
    1   0.011645   0.000008   let i = s:SetNamedColor('#DA70D6','Orchid')
    1   0.012003   0.000008   let i = s:SetNamedColor('#EEE8AA','PaleGoldenRod')
    1   0.011849   0.000008   let i = s:SetNamedColor('#98FB98','PaleGreen')
    1   0.011667   0.000009   let i = s:SetNamedColor('#AFEEEE','PaleTurquoise')
    1   0.012229   0.000008   let i = s:SetNamedColor('#D87093','PaleVioletRed')
    1   0.011588   0.000012   let i = s:SetNamedColor('#FFEFD5','PapayaWhip')
    1   0.022361   0.000009   let i = s:SetNamedColor('#FFDAB9','PeachPuff')
    1   0.019231   0.000021   let i = s:SetNamedColor('#CD853F','Peru')
    1   0.021018   0.000011   let i = s:SetNamedColor('#FFC0CB','Pink')
    1   0.016005   0.000013   let i = s:SetNamedColor('#DDA0DD','Plum')
    1   0.024514   0.000018   let i = s:SetNamedColor('#B0E0E6','PowderBlue')
    1   0.022236   0.000017   let i = s:SetNamedColor('#BC8F8F','RosyBrown')
    1   0.021322   0.000015   let i = s:SetNamedColor('#4169E1','RoyalBlue')
    1   0.011670   0.000010   let i = s:SetNamedColor('#8B4513','SaddleBrown')
    1   0.014544   0.000012   let i = s:SetNamedColor('#FA8072','Salmon')
    1   0.018156   0.000020   let i = s:SetNamedColor('#F4A460','SandyBrown')
    1   0.013097   0.000024   let i = s:SetNamedColor('#2E8B57','SeaGreen')
    1   0.019819   0.000015   let i = s:SetNamedColor('#FFF5EE','SeaShell')
    1   0.018125   0.000011   let i = s:SetNamedColor('#A0522D','Sienna')
    1   0.017482   0.000022   let i = s:SetNamedColor('#87CEEB','SkyBlue')
    1   0.017469   0.000031   let i = s:SetNamedColor('#6A5ACD','SlateBlue')
    1   0.013187   0.000012   let i = s:SetNamedColor('#708090','SlateGray')
    1   0.012713   0.000014   let i = s:SetNamedColor('#708090','SlateGrey')
    1   0.011708   0.000009   let i = s:SetNamedColor('#FFFAFA','Snow')
    1   0.011653   0.000008   let i = s:SetNamedColor('#00FF7F','SpringGreen')
    1   0.011632   0.000012   let i = s:SetNamedColor('#4682B4','SteelBlue')
    1   0.011521   0.000007   let i = s:SetNamedColor('#D2B48C','Tan')
    1   0.011657   0.000007   let i = s:SetNamedColor('#D8BFD8','Thistle')
    1   0.011661   0.000007   let i = s:SetNamedColor('#FF6347','Tomato')
    1   0.011577   0.000007   let i = s:SetNamedColor('#40E0D0','Turquoise')
    1   0.011640   0.000007   let i = s:SetNamedColor('#EE82EE','Violet')
    1   0.011596   0.000007   let i = s:SetNamedColor('#F5DEB3','Wheat')
    1   0.011639   0.000007   let i = s:SetNamedColor('#F5F5F5','WhiteSmoke')
    1   0.012138   0.000007   let i = s:SetNamedColor('#9ACD32','YellowGreen')
                            
                            
                            
    1              0.000001   let i = 1
   13              0.000015   while i <= line("$")
   12   0.000552   0.000049     call s:PreviewCSSColorInLine(i)
   12              0.000013     let i = i+1
   12              0.000007   endwhile
    1              0.000002   unlet i
                            
    1              0.000007   autocmd CursorMoved * silent call s:PreviewCSSColorInLine('.')
    1              0.000003   autocmd CursorMovedI * silent call s:PreviewCSSColorInLine('.')
    1              0.000003   if !exists('g:cssColorVimDoNotMessMyUpdatetime')
    1              0.000008     set ut=100
    1              0.000000   endif
                            
    1              0.000003 endif

FUNCTION  <SNR>91_init_buffer()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002   let b:buffer_vcs_config = {}
    3              0.000005   for vcs in keys(s:vcs_config)
    2              0.000006     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    2              0.000001   endfor
    1              0.000001   unlet! b:airline_head

FUNCTION  <SNR>19_repo_head_ref()
Called 13 times
Total time:   0.001419
 Self time:   0.001142

count  total (s)   self (s)
   13   0.000703   0.000541   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
   13   0.000650   0.000535   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>93_check_mixed_indent_file()
Called 2 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    2              0.000011   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    2              0.000013   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    2              0.000003     let head_spc = '\v(^ +)'
    2              0.000002   endif
    2              0.000016   let indent_tabs = search('\v(^\t+)', 'nw')
    2              0.000017   let indent_spc  = search(head_spc, 'nw')
    2              0.000005   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    2              0.000002     return ''
                              endif

FUNCTION  <SNR>8_LoadFTPlugin()
Called 1 time
Total time:   0.007326
 Self time:   0.002247

count  total (s)   self (s)
    1              0.000016     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    1              0.000013     let s = expand("<amatch>")
    1              0.000004     if s != ""
    1              0.000029       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000023       for name in split(s, '\.')
    1   0.007207   0.002128 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    1              0.000001       endfor
    1              0.000001     endif

FUNCTION  airline#util#exec_funcrefs()
Called 1 time
Total time:   0.000742
 Self time:   0.000092

count  total (s)   self (s)
    8              0.000007     for Fn in a:list
    8   0.000714   0.000064       let code = call(Fn, a:000)
    8              0.000007       if code != 0
    1              0.000001         return code
                                  endif
    7              0.000003     endfor
                                return 0

FUNCTION  <SNR>19_buffer_spec()
Called 12 times
Total time:   0.000316
 Self time:   0.000192

count  total (s)   self (s)
   12              0.000028     let bufname = bufname(self['#'])
   12   0.000283   0.000159     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>108_has_fresh_changes()
Called 6 times
Total time:   0.000246
 Self time:   0.000096

count  total (s)   self (s)
    6   0.000240   0.000090   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>91_update_untracked()
Called 13 times
Total time:   0.002613
 Self time:   0.002240

count  total (s)   self (s)
   13              0.000506   let file = expand("%:p")
   13              0.000156   if empty(file) || isdirectory(file)
                                return
                              endif
                            
   13              0.000047   let needs_update = 1
   39              0.000163   for vcs in keys(s:vcs_config)
   26              0.000274     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
   26              0.000165     if has_key(s:vcs_config[vcs].untracked, file)
   13              0.000037       let needs_update = 0
   13   0.000576   0.000203       call airline#extensions#branch#update_untracked_config(file, vcs)
   13              0.000018     endif
   26              0.000031   endfor
                            
   13              0.000033   if !needs_update
   13              0.000026     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>99_map_keys()
Called 2 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    2              0.000004   if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    2              0.000037     noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
    2              0.000018     noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
    2              0.000015     noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
    2              0.000014     noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
    2              0.000014     noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
    2              0.000014     noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
    2              0.000013     noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
    2              0.000015     noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
    2              0.000013     noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
    2              0.000023     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    2              0.000018     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
    2              0.000002   endif

FUNCTION  <SNR>106_get_accented_line()
Called 16 times
Total time:   0.000570
 Self time:   0.000570

count  total (s)   self (s)
   16              0.000020   if a:self._context.active
   16              0.000017     let contents = []
   16              0.000091     let content_parts = split(a:contents, '__accent')
   32              0.000036     for cpart in content_parts
   16              0.000086       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   16              0.000032       call add(contents, cpart)
   16              0.000015     endfor
   16              0.000038     let line = join(contents, a:group)
   16              0.000093     let line = substitute(line, '__restore__', a:group, 'g')
   16              0.000009   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   16              0.000013   return line

FUNCTION  <SNR>19_repo()
Called 32 times
Total time:   0.001401
 Self time:   0.001401

count  total (s)   self (s)
   32              0.000366   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   32              0.000066   if dir !=# ''
   32              0.000156     if has_key(s:repos, dir)
   32              0.000150       let repo = get(s:repos, dir)
   32              0.000041     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   32              0.000363     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>114_find_current_signs()
Called 1 time
Total time:   0.000080
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000001   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    1              0.000001   let other_signs = []      " [<line_number (number),...]
    1              0.000002   let dummy_sign_placed = 0
                            
    1              0.000002   redir => signs
    1              0.000010     silent execute "sign place buffer=" . a:bufnr
    1              0.000002   redir END
                            
    1              0.000006   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
    1   0.000014   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    1   0.000011   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    1   0.000010   0.000002   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  delimitMate#Set()
Called 46 times
Total time:   0.000858
 Self time:   0.000130

count  total (s)   self (s)
   46   0.000850   0.000122   return call('s:set', a:000)

FUNCTION  airline#check_mode()
Called 13 times
Total time:   0.035728
 Self time:   0.002412

count  total (s)   self (s)
   13              0.000106   let context = s:contexts[a:winnr]
                            
   13              0.000094   if get(w:, 'airline_active', 1)
   13              0.000082     let l:m = mode()
   13              0.000047     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
   13              0.000058       let l:mode = ['normal']
   13              0.000018     endif
   13              0.000121     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   13              0.000021   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   13              0.000075   if g:airline_detect_modified && &modified
    9              0.000143     call add(l:mode, 'modified')
    9              0.000019   endif
                            
   13              0.000050   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   13              0.000114   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   13              0.000047   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   13              0.000042   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   13              0.000125   let mode_string = join(l:mode)
   13              0.000098   if get(w:, 'airline_lastmode', '') != mode_string
    1   0.000198   0.000015     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    1   0.033145   0.000012     call airline#highlighter#highlight(l:mode, context.bufnr)
    1              0.000002     let w:airline_lastmode = mode_string
    1              0.000001   endif
                            
   13              0.000029   return ''

FUNCTION  airline#util#append()
Called 91 times
Total time:   0.001829
 Self time:   0.001829

count  total (s)   self (s)
   91              0.000378   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   91              0.000556   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   91              0.000546   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  htmlcomplete#DetectOmniFlavor()
Called 1 time
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    1              0.000002   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
    1              0.000002     let b:html_omni_flavor = 'html401t'
    1              0.000001   endif
    1              0.000001   let i = 1
    1              0.000001   let line = ""
   10              0.000019   while i < 10 && i < line("$")
    9              0.000015     let line = getline(i)
    9              0.000028     if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
    9              0.000009     let i += 1
    9              0.000003   endwhile
    1              0.000003   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif

FUNCTION  <SNR>117_get_separator_change()
Called 5 times
Total time:   0.001904
 Self time:   0.000038

count  total (s)   self (s)
    5   0.001902   0.000036   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 13 times
Total time:   0.000373
 Self time:   0.000373

count  total (s)   self (s)
   13              0.000106   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>91_update_hg_branch()
Called 13 times
Total time:   0.001138
 Self time:   0.001035

count  total (s)   self (s)
   13   0.000207   0.000104   if s:has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
   13              0.000064     let s:vcs_config['mercurial'].branch = ''
   13              0.000020   endif

FUNCTION  airline#themes#get_highlight()
Called 102 times
Total time:   0.011717
 Self time:   0.000448

count  total (s)   self (s)
  102   0.011684   0.000415   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>47_option_init()
Called 46 times
Total time:   0.001574
 Self time:   0.000564

count  total (s)   self (s)
   46              0.000119   let b = exists("b:delimitMate_" . a:name)
   46              0.000090   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
   46              0.000034   if !b && !g
   46              0.000046     let value = a:default
   46              0.000022   elseif b
                                exec "let value = b:delimitMate_" . a:name
                              else
                                exec "let value = g:delimitMate_" . a:name
                              endif
   46   0.001131   0.000121   call s:set(a:name, value)

FUNCTION  <SNR>84_sync_active_winnr()
Called 3 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    3              0.000035   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 13 times
Total time:   0.001125
 Self time:   0.000926

count  total (s)   self (s)
   13              0.000090   if !exists('b:fugitive_name')
    1              0.000002     let b:fugitive_name = ''
    1              0.000001     try
    1   0.000027   0.000003       let buffer = fugitive#buffer()
    1   0.000179   0.000004       if buffer.type('blob')
                                    let b:fugitive_name = buffer.repo().translate(buffer.path())
                                  endif
    1              0.000001     catch
                                endtry
    1              0.000001   endif
                            
   13              0.000055   if empty(b:fugitive_name)
   13              0.000436     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod)
                              endif

FUNCTION  gitgutter#sign#update_signs()
Called 1 time
Total time:   0.000222
 Self time:   0.000052

count  total (s)   self (s)
    1   0.000088   0.000008   call s:find_current_signs(a:bufnr)
                            
    1              0.000004   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    1   0.000039   0.000014   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    1              0.000003   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    1              0.000001   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    1   0.000035   0.000006   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    1   0.000047   0.000011   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    1              0.000001   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  gitgutter#utility#set_repo_path()
Called 1 time
Total time:   0.000871
 Self time:   0.000121

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    1   0.000018   0.000006   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    1   0.000163   0.000018   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    1   0.000007   0.000005   if g:gitgutter_async && gitgutter#async#available()
    1              0.000002     if has('lambda')
    1   0.000645   0.000054       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
    1              0.000001     else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:not_tracked_by_git') })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                  endif
                                endif
    1              0.000000   else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif

FUNCTION  airline#highlighter#highlight()
Called 1 time
Total time:   0.033133
 Self time:   0.003441

count  total (s)   self (s)
    1              0.000002   let bufnr = a:0 ? a:1 : ''
    1              0.000003   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    1              0.000006   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    1              0.000002   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    2              0.000002   for mode in mapped
    1              0.000001     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    1              0.000005     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    1              0.000003       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   37              0.000052       for kvp in items(dict)
   36              0.000053         let mode_colors = kvp[1]
   36              0.000050         let name = kvp[0]
   36              0.000072         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
   36   0.006369   0.000153         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  108              0.000153         for accent in keys(s:accents)
   72              0.000152           if !has_key(p.accents, accent)
                                        continue
                                      endif
   72              0.000194           let colors = copy(mode_colors)
   72              0.000156           if p.accents[accent][0] != ''
   36              0.000076             let colors[0] = p.accents[accent][0]
   36              0.000018           endif
   72              0.000110           if p.accents[accent][2] != ''
   36              0.000066             let colors[2] = p.accents[accent][2]
   36              0.000009           endif
   72              0.000104           if len(colors) >= 5
   72              0.000178             let colors[4] = get(p.accents[accent], 4, '')
   72              0.000049           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
   72   0.012669   0.000378           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   72              0.000039         endfor
   36              0.000027       endfor
                            
                                  " TODO: optimize this
   28              0.000039       for sep in items(s:separators)
   27   0.011379   0.000194         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   27              0.000016       endfor
    1              0.000001     endif
    1              0.000001   endfor

FUNCTION  <SNR>48_get()
Called 78 times
Total time:   0.000877
 Self time:   0.000877

count  total (s)   self (s)
   78              0.000067   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
    4              0.000012     let bufoptions = get(s:options, bufnr('%'), {})
    4              0.000013     return deepcopy(get(bufoptions, a:name, a:1))
                              else
   74              0.000316     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  fugitive#buffer()
Called 4 times
Total time:   0.000109
 Self time:   0.000019

count  total (s)   self (s)
    4   0.000109   0.000019   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  <SNR>19_repo_tree()
Called 3 times
Total time:   0.000082
 Self time:   0.000067

count  total (s)   self (s)
    3   0.000029   0.000021   if self.dir() =~# '/\.git$'
    3   0.000018   0.000011     let dir = self.dir()[0:-6]
    3              0.000005     if dir !~# '/'
                                  let dir .= '/'
                                endif
    3              0.000003   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
    3              0.000002   if dir ==# ''
                                call s:throw('no work tree')
                              else
    3              0.000008     return join([dir]+a:000,'/')
                              endif

FUNCTION  <SNR>19_shellslash()
Called 14 times
Total time:   0.000148
 Self time:   0.000087

count  total (s)   self (s)
   14   0.000101   0.000040   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   14              0.000012     return a:path
                              endif

FUNCTION  <SNR>47_AutoClose()
Called 2 times
Total time:   0.001532
 Self time:   0.000751

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
    2              0.000002   let i = 0
   10   0.000218   0.000039   while i < len(s:get('matchpairs_list'))
    8   0.000297   0.000048     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
    8   0.000285   0.000043     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
    8              0.000121     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
    8              0.000072     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
    8              0.000009     let i += 1
    8              0.000004   endwhile
                            
                              " Exit from inside the matching pair:
   10   0.000047   0.000013   for delim in s:get('right_delims')
    8              0.000012     let delim = delim == '|' ? '<bar>' : delim
    8              0.000108     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
    8              0.000063     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
    8              0.000001   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
    8   0.000052   0.000013   for delim in s:get('quotes_list')
    6              0.000005     if delim == '|'
                                  let delim = '<Bar>'
                                endif
    6              0.000080     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
    6              0.000047     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
    6              0.000002   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
    2   0.000046   0.000008   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                              endfor

FUNCTION  <SNR>90_get_hunks_gitgutter()
Called 13 times
Total time:   0.001153
 Self time:   0.000341

count  total (s)   self (s)
   13   0.000338   0.000152   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    1              0.000000     return ''
                              endif
   12   0.000758   0.000132   return GitGutterGetHunkSummary()

FUNCTION  <SNR>117_evaluate_tabline()
Called 7 times
Total time:   0.000626
 Self time:   0.000331

count  total (s)   self (s)
    7              0.000009   let tabline = a:tabline
    7   0.000405   0.000110   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
    7              0.000050   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
    7              0.000047   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
    7              0.000025   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
    7              0.000020   let tabline = substitute(tabline, '%=', '', 'g')
    7              0.000024   let tabline = substitute(tabline, '%\d*\*', '', 'g')
    7              0.000022   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
                              endif
    7              0.000006   return tabline

FUNCTION  airline#parts#filetype()
Called 13 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   13              0.000149   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#extensions#term#apply()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000001   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_c', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  <SNR>140_PreviewCSSColorInLine()
Called 18 times
Total time:   0.000769
 Self time:   0.000769

count  total (s)   self (s)
                              " TODO use cssColor matchdata
   18              0.000015   let n = 1
   18              0.000088   let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6\}\>' )
   18              0.000018   while foundcolor != ''
                                if foundcolor =~ '#\x\{6}$'
                                  let color = foundcolor
                                elseif foundcolor =~ '#\x\{3}$'
                                  let color = substitute(foundcolor, '\(\x\)\(\x\)\(\x\)', '\1\1\2\2\3\3', '')
                                else
                                  let color = ''
                                endif
                            
                                if color != ''
                                  call s:SetMatcher(color,foundcolor)
                                endif
                            
                                let n+=1
                                let foundcolor = matchstr( getline(a:where), '#[0-9A-Fa-f]\{3,6}', 0, n )
                              endwhile
                            
                            
   18              0.000012   let n = 1
   18              0.000159   let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
   18              0.000030   while len(foundcolorlist) != 0
                                  let foundcolorlist[1] = s:RGBRelativeToAbsolute( foundcolorlist[1] )
                                  let foundcolorlist[2] = s:RGBRelativeToAbsolute( foundcolorlist[2] )
                                  let foundcolorlist[3] = s:RGBRelativeToAbsolute( foundcolorlist[3] )
                            
                                  let color = "#".join( foundcolorlist[1:3], "" )
                            
                                  call s:SetMatcher( color, foundcolorlist[0] )
                            
                                  let n+=1
                                  let foundcolorlist = matchlist( getline(a:where), 'rgb[a]\=(\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\),\s*\(\d\{1,3}\s*%\=\).\{-})', 0, n )
                              endw
   18              0.000015   return 0

FUNCTION  <SNR>48_set()
Called 46 times
Total time:   0.000728
 Self time:   0.000728

count  total (s)   self (s)
   46              0.000056   let scope = a:0 ? a:1 : 's'
   46              0.000068   let bufnr = bufnr('%')
   46              0.000095   if !exists('s:options[bufnr]')
                                let s:options[bufnr] = {}
                              endif
   46              0.000033   if scope == 's'
   46              0.000083     let name = 's:options.' . bufnr . '.' . a:name
   46              0.000025   else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
                              endif
   46              0.000136   exec 'let ' . name . ' = a:value'

FUNCTION  <SNR>22_unc_path()
Called 2 times
Total time:   0.000078
 Self time:   0.000018

count  total (s)   self (s)
    2   0.000078   0.000018   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  xolox#notes#refresh_syntax()
Called 6 times
Total time:   0.000338
 Self time:   0.000235

count  total (s)   self (s)
                              " Update syntax highlighting of note names and code blocks.
    6   0.000220   0.000117   if xolox#notes#filetype_is_note(&ft) && line('$') > 1
                                let starttime = xolox#misc#timer#start()
                                call xolox#notes#highlight_names(0)
                                call xolox#notes#highlight_sources(0)
                                call xolox#misc#timer#stop("notes.vim %s: Refreshed highlighting in %s.", g:xolox#notes#version, starttime)
                              endif

FUNCTION  <SNR>19_repo_head()
Called 13 times
Total time:   0.003340
 Self time:   0.000913

count  total (s)   self (s)
   13   0.002190   0.000195     let head = s:repo().head_ref()
                            
   13              0.000257     if head =~# '^ref: '
   13   0.000604   0.000172       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
   13              0.000036     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
   13              0.000034     return branch

FUNCTION  <SNR>140_pow()
Called 224910 times
Total time:   0.962959
 Self time:   0.962959

count  total (s)   self (s)
224910              0.183791   let x = a:x
224910              0.352690   for i in range(a:n-1)
224910              0.183973     let x = x*a:x
224910              0.131453   return x

FUNCTION  fugitive#detect()
Called 1 time
Total time:   0.001720
 Self time:   0.000150

count  total (s)   self (s)
    1              0.000004   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    1              0.000002   if !exists('b:git_dir')
    1   0.000450   0.000011     let dir = fugitive#extract_git_dir(a:path)
    1              0.000001     if dir !=# ''
    1              0.000001       let b:git_dir = dir
    1   0.000515   0.000016       if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
    1              0.000001     endif
    1              0.000000   endif
    1              0.000002   if exists('b:git_dir')
    1              0.000004     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    1              0.000001     if !exists('g:fugitive_no_maps')
    1              0.000011       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    1              0.000009       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    1              0.000000     endif
    1   0.000026   0.000004     let buffer = fugitive#buffer()
    1              0.000013     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    1   0.000011   0.000008     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    1              0.000005       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000005       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000000     endif
    1              0.000001     try
    1              0.000007       let [save_mls, &modelines] = [&mls, 0]
    1   0.000281   0.000006       call s:define_commands()
    1   0.000337   0.000005       doautocmd User Fugitive
    1              0.000001     finally
    1              0.000007       let &mls = save_mls
    1              0.000001     endtry
    1              0.000001   endif

FUNCTION  airline#extensions#apply()
Called 1 time
Total time:   0.000067
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000002   let s:active_winnr = winnr()
                            
    1   0.000039   0.000006   if s:is_excluded_window()
                                return -1
                              endif
                            
    1              0.000001   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    1              0.000001   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    1              0.000004   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    1              0.000002   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  airline#extensions#tabline#buflist#list()
Called 8 times
Total time:   0.000224
 Self time:   0.000196

count  total (s)   self (s)
    8              0.000018   if exists('s:current_buffer_list')
    7              0.000007     return s:current_buffer_list
                              endif
                            
    1              0.000003   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    1              0.000003   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    1              0.000002   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    1              0.000006   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    1              0.000001   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
   11              0.000007   for nr in list
   10              0.000013     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                            
                                  " check buffer numbers first
    4              0.000005       if index(exclude_buffers, nr) >= 0
                                    continue
                                    " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                    " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
    4              0.000008       call add(buffers, nr)
    4              0.000001     endif
   10              0.000005   endfor
                            
    1              0.000003   let s:current_buffer_list = buffers
    1              0.000001   return buffers

FUNCTION  <SNR>140_FGforBG()
Called 147 times
Total time:   0.002592
 Self time:   0.002592

count  total (s)   self (s)
                              " takes a 6hex color code and returns a matching color that is visible
  147              0.000679   let pure = substitute(a:bg,'^#','','')
  147              0.000515   let r = eval('0x'.pure[0].pure[1])
  147              0.000374   let g = eval('0x'.pure[2].pure[3])
  147              0.000363   let b = eval('0x'.pure[4].pure[5])
  147              0.000275   if r*30 + g*59 + b*11 > 12000
  105              0.000094     return '#000000'
                              else
   42              0.000033     return '#ffffff'
                              end

FUNCTION  <SNR>91_update_branch()
Called 13 times
Total time:   0.007570
 Self time:   0.001343

count  total (s)   self (s)
   39              0.000190   for vcs in keys(s:vcs_config)
   26   0.006683   0.000456     call {s:vcs_config[vcs].update_branch}()
   26              0.000188     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    1              0.000002       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    1              0.000001       unlet! b:airline_head
    1              0.000001     endif
   26              0.000037   endfor

FUNCTION  airline#extensions#po#apply()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  <SNR>118_ExcludeOther()
Called 4 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    4              0.000022   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
                                return 1 | endif

FUNCTION  <SNR>19_buffer_type()
Called 2 times
Total time:   0.000340
 Self time:   0.000160

count  total (s)   self (s)
    2   0.000011   0.000007   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    2              0.000002     let type = 'file'
    2              0.000002   endif
    2              0.000002   if a:0
    2              0.000010     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  gitgutter#utility#cd_cmd()
Called 2 times
Total time:   0.000233
 Self time:   0.000037

count  total (s)   self (s)
    2   0.000120   0.000025   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    2   0.000112   0.000011   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>140_Xterm2rgb()
Called 255 times
Total time:   0.004665
 Self time:   0.004665

count  total (s)   self (s)
                              " 16 basic colors
  255              0.000166   let r=0
  255              0.000142   let g=0
  255              0.000181   let b=0
  255              0.000180   if a:color<16
   16              0.000026     let r = s:basic16[a:color][0]
   16              0.000025     let g = s:basic16[a:color][1]
   16              0.000020     let b = s:basic16[a:color][2]
   16              0.000011   endif
                            
                              " color cube color
  255              0.000247   if a:color>=16 && a:color<=232
  217              0.000225     let color=a:color-16
  217              0.000296     let r = s:valuerange[(color/36)%6]
  217              0.000281     let g = s:valuerange[(color/6)%6]
  217              0.000259     let b = s:valuerange[color%6]
  217              0.000091   endif
                            
                              " gray tone
  255              0.000226   if a:color>=233 && a:color<=253
   21              0.000024     let r=8+(a:color-232)*0x0a
   21              0.000016     let g=r
   21              0.000013     let b=r
   21              0.000009   endif
  255              0.000327   let rgb=[r,g,b]
  255              0.000157   return rgb

FUNCTION  <SNR>90_get_hunks()
Called 13 times
Total time:   0.001867
 Self time:   0.000714

count  total (s)   self (s)
   13              0.000135   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000002     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    1              0.000001       let b:source_func = 's:get_hunks_gitgutter'
    1              0.000001     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    1              0.000000   endif
   13   0.001349   0.000196   return {b:source_func}()

FUNCTION  <SNR>140_Rgb2xterm()
Called 294 times
Total time:   1.856463
 Self time:   0.893504

count  total (s)   self (s)
  294              0.000406   let best_match=0
  294              0.000330   let smallest_distance = 10000000000
  294              0.000946   let r = eval('0x'.a:color[1].a:color[2])
  294              0.000746   let g = eval('0x'.a:color[3].a:color[4])
  294              0.000704   let b = eval('0x'.a:color[5].a:color[6])
75264              0.045345   for c in range(0,254)
74970   1.575939   0.612980     let d = s:pow(s:colortable[c][0]-r,2) + s:pow(s:colortable[c][1]-g,2) + s:pow(s:colortable[c][2]-b,2)
74970              0.062884     if d<smallest_distance
 1363              0.001279       let smallest_distance = d
 1363              0.001136       let best_match = c
 1363              0.000583     endif
74970              0.031801   endfor
  294              0.000280   return best_match

FUNCTION  <SNR>19_sub()
Called 27 times
Total time:   0.000546
 Self time:   0.000546

count  total (s)   self (s)
   27              0.000525   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  nerdtree#checkForBrowse()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004     if !isdirectory(a:dir)
    1              0.000000         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>114_remove_signs()
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000010   0.000004   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
    1   0.000008   0.000003     let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    1              0.000004     execute "sign unplace * buffer=" . a:bufnr
    1              0.000001     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
    1              0.000000   else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif

FUNCTION  <SNR>22_filename()
Called 1 time
Total time:   0.000031
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000031   0.000004   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>109_build_command()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000004   if has('unix')
    2              0.000003     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 7 times
Total time:   0.000630
 Self time:   0.000094

count  total (s)   self (s)
    7   0.000054   0.000029   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    7              0.000020   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    7   0.000556   0.000045   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>22_is_file_buffer()
Called 7 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    7              0.000094   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>95_wordcount_update()
Called 4 times
Total time:   0.000364
 Self time:   0.000364

count  total (s)   self (s)
    4              0.000026   if empty(bufname(''))
                                return
                              endif
    4              0.000148   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  gitgutter#diff#parse_diff()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000009   let hunks = []
    1              0.000005   for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
    1              0.000001   return hunks

FUNCTION  <SNR>96_update_tabline()
Called 1 time
Total time:   0.000348
 Self time:   0.000224

count  total (s)   self (s)
    1              0.000012   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
    1              0.000021   let match = expand('<afile>')
    1              0.000012   let ignore_bufadd_pat = get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '\c\vgundo|undotree|vimfiler|tagbar|nerd_tree')
    1              0.000005   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || match(match, ignore_bufadd_pat) > -1 || isdirectory(expand("<afile>"))
                                return
                              endif
    1   0.000155   0.000031   doautocmd User BufMRUChange
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    1              0.000016   let &tabline = &tabline

FUNCTION  gitgutter#diff#process_hunks()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001   let modified_lines = []
    1              0.000002   for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
    1              0.000001   return modified_lines

FUNCTION  airline#extensions#tabline#new_builder()
Called 1 time
Total time:   0.000076
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000009   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    1              0.000002   if get(g:, 'airline_powerline_fonts', 0)
    1              0.000003     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
    1              0.000003     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    1              0.000000   else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
                              endif
                            
    1   0.000054   0.000012   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  airline#extensions#tabline#add_label()
Called 1 time
Total time:   0.000022
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1   0.000019   0.000006     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    1              0.000001   endif

FUNCTION  <SNR>9_LoadIndent()
Called 1 time
Total time:   0.000786
 Self time:   0.000206

count  total (s)   self (s)
    1              0.000002     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    1              0.000002     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000001       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000006       for name in split(s, '\.')
    1   0.000764   0.000184 	exe 'runtime! indent/' . name . '.vim'
    1              0.000001       endfor
    1              0.000001     endif

FUNCTION  xolox#easytags#filetypes#canonicalize()
Called 4 times
Total time:   0.000582
 Self time:   0.000240

count  total (s)   self (s)
                              " Select a canonical, supported Vim file type given a value of &filetype.
    4   0.000391   0.000049   call s:discover_supported_filetypes()
                              " Split the possibly combined Vim file type into individual file types.
    5              0.000070   for filetype in split(tolower(a:vim_filetype_value), '\.')
                                " Canonicalize the Vim file type.
    4              0.000034     let filetype = get(s:canonical_filetypes, filetype, filetype)
    4              0.000035     if index(s:supported_filetypes, filetype) >= 0
    3              0.000009       return filetype
                                endif
    1              0.000001   endfor
    1              0.000002   return ''

FUNCTION  airline#extensions#default#apply()
Called 1 time
Total time:   0.000515
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000001   let winnr = a:context.winnr
    1              0.000002   let active = a:context.active
                            
    1   0.000007   0.000004   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    1   0.000194   0.000012     call s:build_sections(a:builder, a:context, s:layout[0])
    1              0.000001   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    1   0.000034   0.000007   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    1   0.000005   0.000003   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    1   0.000263   0.000005     call s:build_sections(a:builder, a:context, s:layout[1])
    1              0.000000   endif
                            
    1              0.000000   return 1

FUNCTION  <SNR>19_buffer_repo()
Called 6 times
Total time:   0.000145
 Self time:   0.000026

count  total (s)   self (s)
    6   0.000144   0.000025   return s:repo(self.getvar('git_dir'))

FUNCTION  <SNR>11_SynSet()
Called 1 time
Total time:   1.903146
 Self time:   0.000448

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000003   syn clear
    1              0.000002   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    1              0.000002   let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    1              0.000000   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    2              0.000007     for name in split(s, '\.')
    1   1.903117   0.000419       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000001     endfor
    1              0.000001   endif

FUNCTION  airline#highlighter#add_separator()
Called 24 times
Total time:   0.010887
 Self time:   0.000235

count  total (s)   self (s)
   24              0.000096   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   24   0.010782   0.000130   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#util#wrap()
Called 91 times
Total time:   0.001023
 Self time:   0.001023

count  total (s)   self (s)
   91              0.000447   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   91              0.000212   return a:text

FUNCTION  <SNR>22_not_git_dir()
Called 7 times
Total time:   0.001225
 Self time:   0.000245

count  total (s)   self (s)
    7   0.001218   0.000238   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  airline#highlighter#get_highlight()
Called 296 times
Total time:   0.031601
 Self time:   0.013365

count  total (s)   self (s)
  296              0.000821   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  296   0.009457   0.001045     let fg = s:get_syn(a:group, 'fg')
  296   0.008893   0.000987     let bg = s:get_syn(a:group, 'bg')
  296              0.004306     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  296              0.001935     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  296              0.000325     let opts = a:000
  296              0.000241     if bold
   36              0.000039       let opts = ['bold']
   36              0.000016     endif
  296   0.003351   0.001433     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  296              0.000148   endif
  296              0.000800   let s:hl_groups[a:group] = res
  296              0.000214   return res

FUNCTION  gitgutter#debug#log()
Called 3 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    3              0.000003   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>102_exec_separator()
Called 51 times
Total time:   0.021837
 Self time:   0.001412

count  total (s)   self (s)
   51              0.000074   if pumvisible()
                                return
                              endif
   51   0.006097   0.000193   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   51   0.005999   0.000186   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   51              0.000117   let group = a:from.'_to_'.a:to.a:suffix
   51              0.000038   if a:inverse
   24              0.000094     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   24              0.000015   else
   27              0.000107     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   27              0.000018   endif
   51              0.000124   let a:dict[group] = colors
   51   0.008929   0.000221   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>81_map()
Called 15 times
Total time:   0.000367
 Self time:   0.000367

count  total (s)   self (s)
   15              0.000072   let from = matchstr(a:map, '\S\+')
   15              0.000075   if empty(mapcheck(from, a:mode))
   15              0.000160     exe a:mode.'map' '<buffer>'.(a:0 ? a:1 : '') a:map
   15              0.000048     let b:undo_ftplugin .= '|sil! '.a:mode.'unmap <buffer> '.from
   15              0.000005   endif

FUNCTION  xolox#misc#cursorhold#autocmd()
Called 5 times
Total time:   0.005968
 Self time:   0.001477

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
   15              0.000074   for handler in g:xolox#misc#cursorhold#handlers
   10              0.000064     let function = handler['function']
   10              0.000073     let last_run = get(handler, 'last_run', 0)
   10              0.000052     let interval = get(handler, 'interval', 4)
   10   0.000405   0.000191     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
   10              0.000108     let time_until_next_run = (last_run + interval) - localtime()
   10              0.000031     if time_until_next_run > 0
    5   0.000194   0.000096       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
    5              0.000008     else
    5   0.000144   0.000058       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    5   0.004228   0.000135       call call(function, get(handler, 'arguments', []))
    5              0.000045       let handler['last_run'] = localtime()
    5              0.000007     endif
   10              0.000016   endfor

FUNCTION  <SNR>140_SetNamedColor()
Called 147 times
Total time:   1.867827
 Self time:   0.008772

count  total (s)   self (s)
  147              0.001558   let group = 'cssColor'.substitute(a:clr,'^#','','')
  147              0.000947   exe 'syn keyword '.group.' '.a:name.' contained'
  147              0.001055   exe 'syn cluster cssColors add='.group
  147              0.000482   if has('gui_running')
                                exe 'hi '.group.' guifg='.s:FGforBG(a:clr)
                                exe 'hi '.group.' guibg='.a:clr
                              elseif &t_Co == 256
  147   0.933182   0.001800     exe 'hi '.group.' ctermfg='.s:Rgb2xterm(s:FGforBG(a:clr))
  147   0.929570   0.001897     exe 'hi '.group.' ctermbg='.s:Rgb2xterm(a:clr)
  147              0.000072   endif
  147              0.000110   return 23

FUNCTION  airline#extensions#tabline#get()
Called 2 times
Total time:   0.012262
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000007   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    2              0.000004   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    2              0.000003   let curtabcnt = tabpagenr('$')
    2              0.000004   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
    2              0.000005   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
    2              0.000002   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
    2   0.012216   0.000017     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>19_buffer_path()
Called 1 time
Total time:   0.000464
 Self time:   0.000074

count  total (s)   self (s)
    1   0.000043   0.000014   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    1              0.000001   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
    1   0.000085   0.000007     let rev = self.spec()[strlen(self.repo().tree()) : -1]
    1              0.000001   endif
    1   0.000025   0.000004   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  <SNR>15_init()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  airline#util#getwinvar()
Called 13 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
   13              0.000029     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>47_Unmap()
Called 1 time
Total time:   0.000467
 Self time:   0.000402

count  total (s)   self (s)
    1   0.000091   0.000027   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
   35              0.000019   for map in imaps
   34              0.000188     if maparg(map, "i") =~# '^<Plug>delimitMate'
   16              0.000008       if map == '|'
                                    let map = '<Bar>'
                                  endif
   16              0.000059       exec 'silent! iunmap <buffer> ' . map
   16              0.000005     endif
   34              0.000014   endfor
    1   0.000010   0.000009   silent! doautocmd <nomodeline> User delimitMate_unmap
    1              0.000001   let b:delimitMate_enabled = 0

FUNCTION  <SNR>93_check_mixed_indent()
Called 2 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
    2              0.000008   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    2              0.000003   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    2              0.000175     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008   let s:current_bufnr = -1

FUNCTION  <SNR>91_has_fugitive()
Called 13 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   13              0.000089   return exists('*fugitive#head')

FUNCTION  <SNR>19_repo_bare()
Called 1 time
Total time:   0.000015
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000014   0.000011   if self.dir() =~# '/\.git$'
    1              0.000001     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 1 time
Total time:   0.000010
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000010   0.000003   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>83_foldable()
Called 12 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
   12              0.000027   if index(s:foldable_groups, 'ALL') > -1
   12              0.000009     return 1
                              endif
                            
                              for l:i in a:000
                                if index(s:foldable_groups, l:i) > -1
                                  return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  xolox#session#auto_save_periodic()
Called 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
    1              0.000007   if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
                              endif

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.000439
 Self time:   0.000249

count  total (s)   self (s)
    1   0.000022   0.000008   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    1              0.000004   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
    1              0.000015     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    1              0.000001   endif
    1   0.000027   0.000017   let root = s:shellslash(resolve(path))
    1              0.000001   let previous = ""
    4              0.000005   while root !=# previous
    4              0.000014     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    4              0.000017     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    4              0.000009     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    4   0.000066   0.000015     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    4   0.000049   0.000013     let dir = s:sub(root, '[\/]$', '') . '/.git'
    4              0.000015     let type = getftype(dir)
    4   0.000026   0.000006     if type ==# 'dir' && fugitive#is_git_dir(dir)
    1              0.000001       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
    3              0.000004     let previous = root
    3              0.000006     let root = fnamemodify(root, ':h')
    3              0.000003   endwhile
                              return ''

FUNCTION  <SNR>47_init()
Called 2 times
Total time:   0.002378
 Self time:   0.000480

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
    2   0.000104   0.000008   call s:option_init("autoclose", 1)
                              " matchpairs
    2   0.000088   0.000014   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
    2   0.000191   0.000073   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
    2   0.000044   0.000006   let pairs = s:get('matchpairs_list')
    2              0.000017   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
                              endif
    2   0.000129   0.000021   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
    2   0.000124   0.000019   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
    2   0.000073   0.000007   call s:option_init("quotes", "\" ' `")
    2   0.000138   0.000033   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
    2   0.000074   0.000007   call s:option_init("nesting_quotes", [])
                              " excluded_regions
    2   0.000072   0.000006   call s:option_init("excluded_regions", "Comment")
    2   0.000116   0.000014   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
    2   0.000042   0.000008   let enabled = len(s:get('excluded_regions_list')) > 0
    2   0.000074   0.000007   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
    2              0.000006   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
                              endif
    2              0.000005   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
                              endif
    2   0.000071   0.000006   call s:option_init("expand_space", 0)
                              " expand_cr
    2              0.000006   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
                              endif
    2              0.000004   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
                              endif
    2              0.000014   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                              endif
    2   0.000070   0.000005   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
    2   0.000072   0.000007   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
    2   0.000069   0.000006   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
    2   0.000073   0.000008   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
    2   0.000047   0.000012   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
    2              0.000008   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
    2              0.000006   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
                              endif
    2              0.000005   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
                              endif
    2   0.000076   0.000007   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
    2   0.000072   0.000006   call s:option_init("apostrophes", "")
    2   0.000118   0.000016   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
    2   0.000070   0.000005   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
    2   0.000071   0.000007   call s:option_init("balance_matchpairs", 0)
                              " eol marker
    2   0.000068   0.000004   call s:option_init("insert_eol_marker", 1)
    2   0.000071   0.000007   call s:option_init("eol_marker", "")
                              " Everything is fine.
    2              0.000000   return 1

FUNCTION  airline#util#shorten()
Called 27 times
Total time:   0.001015
 Self time:   0.001015

count  total (s)   self (s)
   27              0.000394   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
    1              0.000001     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
    1              0.000015       return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
                              else
   26              0.000066     return a:text
                              endif

FUNCTION  <SNR>93_ws_refresh()
Called 5 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    5              0.000047   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    4              0.000010     return
                              endif
    1              0.000004   unlet! b:airline_whitespace_check
    1              0.000004   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    1              0.000004   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 9 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    9              0.000016   let cur = bufnr('%')
    9              0.000011   if cur == a:bufnr
    2              0.000008     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod'
                                else
    2              0.000002       let group = 'airline_tabsel'
    2              0.000002     endif
    2              0.000000   else
    7              0.000026     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    3              0.000004       let group = 'airline_tabmod_unsel'
    3              0.000004     elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
    4              0.000004       let group = 'airline_tabhid'
    4              0.000001     endif
    7              0.000005   endif
    9              0.000007   return group

FUNCTION  HtmlIndent_CheckUserSettings()
Called 1 time
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
                              "{{{
    1              0.000002   let inctags = ''
    1              0.000002   if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
    1              0.000001   let b:hi_tags = {}
    1              0.000002   if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
    1              0.000001   let autotags = ''
    1              0.000002   if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
    1              0.000002   let b:hi_removed_tags = {}
    1              0.000002   if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
    1              0.000001   let string_names = []
    1              0.000003   if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
    1              0.000001   let b:hi_insideStringNames = ['htmlString']
    1              0.000002   if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
    1              0.000001   let tag_names = []
    1              0.000001   if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
    1              0.000003   let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
    1              0.000002   if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
    1              0.000003   let indone = {"zero": 0,"auto": "indent(prevnonblank(v:lnum-1))","inc": "b:hi_indent.blocktagind + shiftwidth()"}
                            
    1              0.000001   let script1 = ''
    1              0.000001   if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
    1              0.000001     let script1 = g:html_indent_script1
    1              0.000001   endif
    1              0.000001   if len(script1) > 0
    1              0.000003     let b:hi_js1indent = get(indone, script1, indone.zero)
    1              0.000000   else
                                let b:hi_js1indent = 0
                              endif
                            
    1              0.000001   let style1 = ''
    1              0.000001   if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
    1              0.000001   if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
    1              0.000002     let b:hi_css1indent = 0
    1              0.000000   endif
                            
    1              0.000002   if !exists('b:html_indent_line_limit')
    1              0.000001     if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
    1              0.000001       let b:html_indent_line_limit = 200
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  gitgutter#utility#extension()
Called 1 time
Total time:   0.000056
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000056   0.000007   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>19_define_commands()
Called 1 time
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
   28              0.000020   for command in s:commands
   27              0.000235     exe 'command! -buffer '.command
   27              0.000014   endfor

FUNCTION  airline#builder#get_next_group()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002   let x = a:i + 1
    1              0.000003   let l = len(a:sections)
    2              0.000002   while x < l
    2              0.000004     let group = a:sections[x][0]
    2              0.000002     if group != '' && group != '|'
    1              0.000000       return group
                                endif
    1              0.000001     let x = x + 1
    1              0.000001   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
Called 13 times
Total time:   0.000820
 Self time:   0.000820

count  total (s)   self (s)
   13              0.000115   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   13              0.000057   let bomb     = &l:bomb ? '[BOM]' : ''
   13              0.000306   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   13              0.000152   if expected is# &fenc.bomb.ff
                                return ''
                              else
   13              0.000126     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>22_dir()
Called 9 times
Total time:   0.001081
 Self time:   0.000178

count  total (s)   self (s)
    9   0.001073   0.000170   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  gitgutter#utility#shellescape()
Called 12 times
Total time:   0.000463
 Self time:   0.000456

count  total (s)   self (s)
   12              0.000406   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   11              0.000027     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    1              0.000003     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>19_buffer_commit()
Called 2 times
Total time:   0.000076
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000076   0.000017   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>106_section_is_empty()
Called 19 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   19              0.000019   let start=1
                            
                              " do not check for inactive windows or the tabline
   19              0.000023   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
   11              0.000005     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
    8              0.000015   if get(g:, 'airline_skip_empty_sections', 0) == 0
    8              0.000003     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>107_build_sections()
Called 2 times
Total time:   0.000440
 Self time:   0.000072

count  total (s)   self (s)
   10              0.000009   for key in a:keys
    8              0.000014     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
    8   0.000394   0.000026     call s:add_section(a:builder, a:context, key)
    8              0.000005   endfor

FUNCTION  gitgutter#async#available()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000002   return s:available

FUNCTION  <SNR>107_get_section()
Called 10 times
Total time:   0.000238
 Self time:   0.000214

count  total (s)   self (s)
   10              0.000020   if has_key(s:section_truncate_width, a:key)
    7              0.000014     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
    7              0.000001   endif
   10              0.000012   let spc = g:airline_symbols.space
   10              0.000029   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   10   0.000066   0.000042   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   10              0.000041   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   10              0.000024   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>90_is_branch_empty()
Called 13 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
   13              0.000174   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>107_add_section()
Called 8 times
Total time:   0.000368
 Self time:   0.000136

count  total (s)   self (s)
    8              0.000024     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
    8   0.000069   0.000025     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    1              0.000001       return
                                endif
    7              0.000005     if condition
                                  call a:builder.add_raw('%(')
                                endif
    7   0.000229   0.000041     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
    7              0.000005     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  airline#builder#get_prev_group()
Called 20 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   20              0.000032   let x = a:i - 1
   23              0.000021   while x >= 0
   19              0.000036     let group = a:sections[x][0]
   19              0.000028     if group != '' && group != '|'
   16              0.000011       return group
                                endif
    3              0.000003     let x = x - 1
    3              0.000003   endwhile
    4              0.000003   return ''

FUNCTION  <SNR>71_Highlight_Matching_Pair()
Called 3 times
Total time:   0.001771
 Self time:   0.001771

count  total (s)   self (s)
                              " Remove any previous match.
    3              0.000044   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    3              0.000036   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    3              0.000026   let c_lnum = line('.')
    3              0.000020   let c_col = col('.')
    3              0.000010   let before = 0
                            
    3              0.000024   let text = getline(c_lnum)
    3              0.000136   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    3              0.000021   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    3              0.000039     let [c_before, c] = matches[1:2]
    3              0.000007   endif
    3              0.000136   let plist = split(&matchpairs, '.\zs[:,]')
    3              0.000029   let i = index(plist, c)
    3              0.000011   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000024     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    2              0.000006     if i < 0
                                  " not found, nothing to do
    2              0.000008       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000001   if i % 2 == 0
    1              0.000001     let s_flags = 'nW'
    1              0.000003     let c2 = plist[i + 1]
    1              0.000000   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
    1              0.000001   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000001   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
    1              0.000004   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    1              0.000003     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    1              0.000001     try
    1              0.000163       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
    1              0.000002     catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
    1              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    1              0.000003   let stoplinebottom = line('w$')
    1              0.000001   let stoplinetop = line('w0')
    1              0.000001   if i % 2 == 0
    1              0.000003     let stopline = stoplinebottom
    1              0.000000   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000003   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    1              0.000004     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000000   endif
    1              0.000001   try
    1              0.000700     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    1              0.000001   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    1              0.000001   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    1              0.000002   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    1              0.000003     if exists('*matchaddpos')
    1              0.000029       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    1              0.000001     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    1              0.000003     let w:paren_hl_on = 1
    1              0.000000   endif

FUNCTION  <SNR>19_cpath()
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    5              0.000008   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
    5              0.000004     return a:path
                              endif

FUNCTION  delimitMate#Get()
Called 78 times
Total time:   0.001090
 Self time:   0.000213

count  total (s)   self (s)
   78   0.001076   0.000199   return call('s:get', a:000)

FUNCTION  airline#parts#paste()
Called 13 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   13              0.000065   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>81_build_path()
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000016   let path = join(map(copy(a:path), 'v:val ==# "." ? "" : v:val'), ',')
    1              0.000009   if &g:path !~# '\v^\.%(,/%(usr|emx)/include)=,,$'
                                let path = substitute(&g:path,',,$',',','') . ',' . path
                              endif
    1              0.000001   return path

FUNCTION  airline#update_statusline()
Called 1 time
Total time:   0.008444
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000010   0.000007   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    1              0.000006   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
    1              0.000002   unlet! w:airline_render_left w:airline_render_right
    1              0.000009   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    1              0.000002   let w:airline_active = 1
    1              0.000004   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    1   0.008399   0.000008   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>91_display_git_branch()
Called 1 time
Total time:   0.000096
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000003   let name = b:buffer_vcs_config['git'].branch
    1              0.000001   try
    1   0.000075   0.000009     let commit = fugitive#buffer().commit()
                            
    1              0.000003     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
                                elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
                                endif
    1              0.000001   catch
                              endtry
                            
    1              0.000001   return name

FUNCTION  <SNR>102_Get()
Called 14 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
   14              0.000024   let res=get(a:dict, a:key, '')
   14              0.000009   if res is ''
    7              0.000003     return ''
                              else
    7              0.000007     return a:prefix. res
                              endif

FUNCTION  <SNR>106_get_transitioned_seperator()
Called 12 times
Total time:   0.011231
 Self time:   0.000344

count  total (s)   self (s)
   12              0.000010   let line = ''
   12   0.005688   0.000052   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   12              0.000045   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   12   0.005306   0.000055     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   12              0.000036     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   12              0.000036     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   12              0.000020     let line .= '%#'.a:group.'#'
   12              0.000004   endif
   12              0.000011   return line

FUNCTION  <SNR>19_can_diffoff()
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000034   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  BuffergatorUpdateMRU()
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000007     if len(g:buffergator_mru) < 1 " maybe should be 2?
                                    if g:buffergator_mru_cycle_loop
                                        let g:buffergator_mru = []
                                        for l:bni in range(bufnr("$"), 1, -1)
                                            if buflisted(l:bni)   && getbufvar(l:bni, "&filetype") != "netrw"
                                                call add(g:buffergator_mru, l:bni)
                                            endif
                                        endfor
                                    endif
                                endif
    2              0.000004     if !exists("w:buffergator_mru")
                                    let w:buffergator_mru = g:buffergator_mru[:]
                                endif
    2              0.000002     if g:buffergator_track_mru
    2              0.000004         let bnum = a:acmd_bufnr + 0
                                    " if bnum == 0 || !buflisted(bnum) || !(empty(getbufvar(bnum, "netrw_browser_active")))
    2              0.000009         if bnum == 0 || !buflisted(bnum) || getbufvar(bnum, "&filetype") == "netrw"
                                        return
                                    endif
    2              0.000013         call filter(g:buffergator_mru, 'v:val !=# bnum')
    2              0.000004         call insert(g:buffergator_mru, bnum, 0)
    2              0.000012         call filter(w:buffergator_mru, 'v:val !=# bnum')
    2              0.000004         call insert(w:buffergator_mru, bnum, 0)
    2              0.000001     endif

FUNCTION  airline#parts#readonly()
Called 13 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   13              0.000088   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   13              0.000053     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>25_record()
Called 3 times
Total time:   0.001158
 Self time:   0.000241

count  total (s)   self (s)
    3              0.000028 	if s:locked | retu | en
    3              0.000022 	let bufnr = a:bufnr + 0
    3              0.000023 	let bufname = bufname(bufnr)
    3              0.000019 	if bufnr > 0 && !empty(bufname)
    3              0.000071 		cal filter(s:mrbs, 'v:val != bufnr')
    3              0.000015 		cal insert(s:mrbs, bufnr)
    3   0.000962   0.000045 		cal s:addtomrufs(bufname)
    3              0.000005 	en

FUNCTION  <SNR>109_on_exit_vim()
Called 2 times
Total time:   0.000493
 Self time:   0.000023

count  total (s)   self (s)
    2   0.000492   0.000022   call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))

FUNCTION  gitgutter#utility#setbufvar()
Called 8 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    8              0.000031   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
    8              0.000017   let needs_setting = empty(dict)
    8              0.000015   let dict[a:varname] = a:val
    8              0.000008   if needs_setting
    1              0.000003     call setbufvar(a:buffer, 'gitgutter', dict)
    1              0.000000   endif

FUNCTION  airline#builder#should_change_group()
Called 18 times
Total time:   0.004081
 Self time:   0.000295

count  total (s)   self (s)
   18              0.000024   if a:group1 == a:group2
    1              0.000001     return 0
                              endif
   17   0.002082   0.000069   let color1 = airline#highlighter#get_highlight(a:group1)
   17   0.001840   0.000067   let color2 = airline#highlighter#get_highlight(a:group2)
   17              0.000018   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   17              0.000049     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#highlighter#exec()
Called 160 times
Total time:   0.027371
 Self time:   0.006864

count  total (s)   self (s)
  160              0.000194   if pumvisible()
                                return
                              endif
  160              0.000191   let colors = a:colors
  160              0.000141   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  160   0.017073   0.000527   let old_hi = airline#highlighter#get_highlight(a:group)
  160              0.000261   if len(colors) == 4
   51              0.000099     call add(colors, '')
   51              0.000023   endif
  160              0.000154   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  160              0.000824     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  160              0.000086   endif
  160   0.002126   0.000492   let colors = s:CheckDefined(colors)
  160   0.002855   0.000582   if old_hi != new_hi || !s:hl_group_exists(a:group)
    2   0.000092   0.000038     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
    2              0.000021     exe cmd
    2              0.000006     if has_key(s:hl_groups, a:group)
    2              0.000002       let s:hl_groups[a:group] = colors
    2              0.000001     endif
    2              0.000001   endif

FUNCTION  <SNR>102_CheckDefined()
Called 160 times
Total time:   0.001634
 Self time:   0.001634

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  160              0.000364   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  160              0.000338   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  160              0.000151     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>113_reset_summary()
Called 1 time
Total time:   0.000014
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000014   0.000005   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#whitespace#check()
Called 13 times
Total time:   0.003629
 Self time:   0.002813

count  total (s)   self (s)
   13              0.000112   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   13              0.000174   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
   13              0.000087   if !exists('b:airline_whitespace_check')
    2              0.000004     let b:airline_whitespace_check = ''
    2              0.000012     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    2              0.000003     let trailing = 0
    2              0.000006     if index(checks, 'trailing') > -1
    2              0.000003       try
    2              0.000007         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    2              0.000117         let trailing = search(regexp, 'nw')
    2              0.000003       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    2              0.000002     endif
                            
    2              0.000003     let mixed = 0
    2              0.000003     let check = 'indent'
    2              0.000025     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    2   0.000231   0.000019       let mixed = s:check_mixed_indent()
    2              0.000002     endif
                            
    2              0.000003     let mixed_file = ''
    2              0.000003     let check = 'mixed-indent-file'
    2              0.000020     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    2   0.000100   0.000015       let mixed_file = s:check_mixed_indent_file()
    2              0.000002     endif
                            
    2              0.000003     let long = 0
    2              0.000006     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    2              0.000008     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    2              0.000001   endif
   13   0.000667   0.000148   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 7 times
Total time:   0.000511
 Self time:   0.000419

count  total (s)   self (s)
    7              0.000016   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    7              0.000005   let _ = ''
                            
    7              0.000014   let name = bufname(a:bufnr)
    7              0.000011   if empty(name)
                                let _ .= '[No Name]'
                              else
    7              0.000007     if s:fnamecollapse
    7              0.000245       let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    7              0.000006     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
    7              0.000026     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
    7              0.000004   endif
                            
    7   0.000130   0.000038   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 7 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    7              0.000015   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    7              0.000032   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    7              0.000018   if getbufvar(a:bufnr, '&modified') == 1
    3              0.000005     let _ .= s:buf_modified_symbol
    3              0.000001   endif
    7              0.000006   return _

FUNCTION  <SNR>47_ExtraMappings()
Called 2 times
Total time:   0.000439
 Self time:   0.000331

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
    2              0.000018   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
    2              0.000016   if !hasmapto('<Plug>delimitMateBS','i')
    2              0.000010     if empty(maparg('<BS>', 'i'))
    2              0.000013       silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
    2              0.000001     endif
    2              0.000010     if empty(maparg('<C-H>', 'i'))
    2              0.000012       silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
    2              0.000000     endif
    2              0.000001   endif
                              " If pair is empty, delete closing delimiter:
    2              0.000021   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
    2              0.000022   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
    2              0.000014     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
    2              0.000000   endif
                              " Expand return if inside an empty pair:
    2              0.000020   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
    2   0.000048   0.000008   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
                              endif
                              " Expand space if inside an empty pair:
    2              0.000020   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
    2   0.000044   0.000009   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                              endif
                              " Jump over any delimiter:
    2              0.000021   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
    2   0.000060   0.000027   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
    2              0.000014     silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
    2              0.000002   endif
                              " Jump over next delimiters
    2              0.000022   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
    2              0.000022   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
    2              0.000014     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
    2              0.000000   endif

FUNCTION  <SNR>22_strip_trailing_new_line()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000016   return substitute(a:line, '\n$', '', '')

FUNCTION  <SNR>109_on_stdout_vim()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000014   call add(self.stdoutbuffer, a:data)

FUNCTION  <SNR>47_get()
Called 78 times
Total time:   0.001315
 Self time:   0.000225

count  total (s)   self (s)
   78   0.001304   0.000214   return call('delimitMate#Get', a:000)

FUNCTION  294()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   return len(self._sections)

FUNCTION  <SNR>47_setup()
Called 2 times
Total time:   0.005085
 Self time:   0.000087

count  total (s)   self (s)
    2              0.000004   let swap = a:0 && a:1 == 2
    2              0.000002   let enable = a:0 && a:1
    2              0.000002   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
    2              0.000005   if get(b:, 'delimitMate_enabled', 0)
    1   0.000471   0.000004     call s:Unmap()
                                " Switch
    1              0.000001     if swap
                                  echo "delimitMate is disabled."
                                  return
                                endif
    1              0.000001   endif
    2              0.000002   if disable
                                " Just disable the mappings.
                                return
                              endif
    2              0.000002   if !a:0
                                " Check if this file type is excluded:
    2              0.000008     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
                                endif
                                " Check if user tried to disable using b:loaded_delimitMate
    2              0.000003     if exists("b:loaded_delimitMate")
                                  return 1
                                endif
    2              0.000001   endif
                              " Initialize settings:
    2   0.002389   0.000011   if ! s:init()
                                " Something went wrong.
                                return
                              endif
    2              0.000004   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
    2   0.002163   0.000010     call s:Map()
    2              0.000001     if a:0
                                  echo "delimitMate is enabled."
                                endif
    2              0.000000   endif

FUNCTION  <SNR>25_addtomrufs()
Called 3 times
Total time:   0.000917
 Self time:   0.000917

count  total (s)   self (s)
    3              0.000112 	let fn = fnamemodify(a:fname, ':p')
    3              0.000044 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    3              0.000545 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    3              0.000042 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    3              0.000007 	if idx
    3              0.000085 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    3              0.000016 		cal insert(s:mrufs, fn)
    3              0.000019 		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    3              0.000003 	en

FUNCTION  gitgutter#process_buffer()
Called 6 times
Total time:   0.009789
 Self time:   0.000571

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    6   0.002560   0.000098   if gitgutter#utility#is_active(a:bufnr)
    6   0.000340   0.000094     if a:force || s:has_fresh_changes(a:bufnr)
                            
    1              0.000002       let diff = ''
    1              0.000000       try
    1   0.006559   0.000049         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
    1              0.000002       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    1              0.000002       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    1              0.000001     endif
    6              0.000009   endif

FUNCTION  gitgutter#utility#repo_path()
Called 5 times
Total time:   0.000098
 Self time:   0.000034

count  total (s)   self (s)
    5   0.000061   0.000019   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    5   0.000035   0.000013   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>111_save_last_seen_change()
Called 1 time
Total time:   0.000014
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000013   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>102_get_array()
Called 296 times
Total time:   0.001918
 Self time:   0.001918

count  total (s)   self (s)
  296              0.000779   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  296              0.001031   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  gitgutter#utility#windows()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000017   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 13 times
Total time:   0.000671
 Self time:   0.000671

count  total (s)   self (s)
   13              0.000308   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   13              0.000050   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   13              0.000026   return ''

FUNCTION  gitgutter#hunk#summary()
Called 12 times
Total time:   0.000477
 Self time:   0.000188

count  total (s)   self (s)
   12   0.000465   0.000176   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>19_buffer_getline()
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000021   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  <SNR>19_buffer_getvar()
Called 15 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   15              0.000038   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>19_buffer()
Called 6 times
Total time:   0.000131
 Self time:   0.000111

count  total (s)   self (s)
    6              0.000023   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    6              0.000054   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    6   0.000044   0.000024   if buffer.getvar('git_dir') !=# ''
    6              0.000005     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>102_get_syn()
Called 592 times
Total time:   0.016318
 Self time:   0.016318

count  total (s)   self (s)
  592              0.001122   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  592              0.000506   let color = ''
  592              0.003540   if hlexists(a:group)
  586              0.004574     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  586              0.000312   endif
  592              0.001044   if empty(color) || color == -1
                                " should always exists
   23              0.000211     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   23              0.000031     if empty(color) || color == -1
   23              0.000019       let color = 'NONE'
   23              0.000011     endif
   23              0.000009   endif
  592              0.000490   return color

FUNCTION  <SNR>22_abs_path()
Called 20 times
Total time:   0.001429
 Self time:   0.001429

count  total (s)   self (s)
   20              0.001288   let p = resolve(expand('#'.a:bufnr.':p'))
   20              0.000115   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  xolox#notes#filetype_is_note()
Called 6 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
                              " Check whether the given file type value refers to the notes.vim plug-in.
    6              0.000092   return index(split(a:ft, '\.'), 'notes') >= 0

FUNCTION  gitgutter#init_buffer()
Called 1 time
Total time:   0.001047
 Self time:   0.000042

count  total (s)   self (s)
    1   0.000121   0.000004   if gitgutter#utility#is_active(a:bufnr)
    1   0.000023   0.000006     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    1              0.000002     if type(p) != s:t_string || empty(p)
    1   0.000896   0.000025       call gitgutter#utility#set_repo_path(a:bufnr)
    1              0.000000     endif
    1              0.000001   endif

FUNCTION  airline#parts#crypt()
Called 13 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   13              0.000153   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
Called 13 times
Total time:   0.000323
 Self time:   0.000323

count  total (s)   self (s)
   13              0.000162   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   13              0.000146     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  fugitive#is_git_dir()
Called 8 times
Total time:   0.000130
 Self time:   0.000073

count  total (s)   self (s)
    8   0.000082   0.000025   let path = s:sub(a:path, '[\/]$', '') . '/'
    8              0.000044   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  airline#extensions#branch#head()
Called 13 times
Total time:   0.011069
 Self time:   0.000723

count  total (s)   self (s)
   13              0.000082   if !exists('b:buffer_vcs_config')
    1   0.000028   0.000009     call s:init_buffer()
    1              0.000001   endif
                            
   13   0.007703   0.000133   call s:update_branch()
   13   0.002746   0.000133   call s:update_untracked()
                            
   13              0.000112   if exists('b:airline_head') && !empty(b:airline_head)
   12              0.000037     return b:airline_head
                              endif
                            
    1              0.000001   let b:airline_head = ''
    1              0.000003   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    1              0.000001   let heads = []
    3              0.000002   for vcs in vcs_priority
    2              0.000004     if !empty(b:buffer_vcs_config[vcs].branch)
    1              0.000002       let heads += [vcs]
    1              0.000001     endif
    2              0.000000   endfor
                            
    2              0.000002   for vcs in heads
    1              0.000002     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    1              0.000001     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
    1   0.000118   0.000020     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    1              0.000003     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    1              0.000000   endfor
                            
    1              0.000002   if empty(heads)
                                if s:has_vcscommand()
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    1              0.000001   if empty(heads)
                                if s:has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
    1              0.000002   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '' : '.')
                                endif
                              endif
                            
    1              0.000003   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    1   0.000052   0.000006   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    1              0.000001   return b:airline_head

FUNCTION  <SNR>84_is_excluded_window()
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000002   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
    4              0.000004   for matchw in g:airline_exclude_filenames
    3              0.000013     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
    3              0.000002   endfor
                            
    1              0.000001   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    1              0.000001   return 0

FUNCTION  gitgutter#diff#run_diff()
Called 1 time
Total time:   0.006510
 Self time:   0.005441

count  total (s)   self (s)
    2   0.000039   0.000009   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
    1   0.005338   0.005250     sleep 5m
    1              0.000001   endwhile
                            
    1   0.000016   0.000003   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    1              0.000001   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
    1              0.000005   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    1              0.000002   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    1   0.000063   0.000007   let extension = gitgutter#utility#extension(a:bufnr)
    1              0.000003   if !empty(extension)
    1              0.000002     let index_file .= '.'.extension
    1              0.000002     let buff_file .= '.'.extension
    1              0.000001   endif
                            
                              " Write file from index to temporary file.
    1   0.000045   0.000007   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    1              0.000004   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    1   0.000074   0.000013   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
    1              0.000003   let cmd .= g:gitgutter_git_executable.' --no-pager'
    1              0.000001   if s:c_flag
    1              0.000001     let cmd .= ' -c "diff.autorefreshindex=0"'
    1              0.000003     let cmd .= ' -c "diff.noprefix=false"'
    1              0.000003     let cmd .= ' -c "core.safecrlf=false"'
    1              0.000001   endif
    1              0.000005   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    1              0.000003   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    1   0.000036   0.000009     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    1              0.000000   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    1              0.000003   let cmd .= ' || exit 0'
                            
    1              0.000002   let cmd .= ')'
                            
    1   0.000139   0.000012   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    1   0.000015   0.000011   if g:gitgutter_async && gitgutter#async#available()
    1   0.000670   0.000045     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    1              0.000004     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  GitGutterGetHunkSummary()
Called 12 times
Total time:   0.000626
 Self time:   0.000149

count  total (s)   self (s)
   12   0.000619   0.000142   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000020   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  xolox#easytags#session_is_loading()
Called 4 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    4              0.000031   return exists('g:SessionLoad')

FUNCTION  xolox#misc#msg#debug()
Called 20 times
Total time:   0.000398
 Self time:   0.000398

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
   20              0.000091   if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif

FUNCTION  airline#util#strchars()
Called 7 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    7              0.000013   if exists('*strchars')
    7              0.000011     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  gitgutter#async#execute()
Called 2 times
Total time:   0.001216
 Self time:   0.001149

count  total (s)   self (s)
    2   0.000070   0.000012   call gitgutter#debug#log('[async] '.a:cmd)
                            
    2              0.000008   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    2   0.000018   0.000009   let command = s:build_command(a:cmd)
                            
    2              0.000006   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    2              0.001080     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    2              0.000006   endif

FUNCTION  <SNR>19_winshell()
Called 14 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
   14              0.000057   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>91_has_lawrencium()
Called 13 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   13              0.000092   return exists('*lawrencium#statusline')

FUNCTION  airline#extensions#wordcount#apply()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000014   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  gitgutter#diff#handler()
Called 1 time
Total time:   0.000409
 Self time:   0.000066

count  total (s)   self (s)
    1   0.000035   0.000009   call gitgutter#debug#log(a:diff)
                            
    1   0.000073   0.000009   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    1   0.000027   0.000010   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    1              0.000002   let signs_count = len(modified_lines)
    1              0.000001   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    1              0.000001     if g:gitgutter_signs || g:gitgutter_highlight_lines
    1   0.000234   0.000012       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    1              0.000001     endif
    1              0.000000   endif
                            
    1   0.000019   0.000005   call s:save_last_seen_change(a:bufnr)
    1              0.000005   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  <SNR>22_winshell()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>114_obsolete_gitgutter_signs_to_remove()
Called 1 time
Total time:   0.000025
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000001   let signs_to_remove = []  " list of [<id (number)>, ...]
    1              0.000001   let remove_all_signs = 1
    1   0.000010   0.000004   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
    1              0.000002   for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
    1              0.000003   let s:remove_all_old_signs = remove_all_signs
    1              0.000001   return signs_to_remove

FUNCTION  airline#extensions#tabline#builder#new()
Called 1 time
Total time:   0.000042
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000033   0.000007   let builder = airline#builder#new(a:context)
    1              0.000001   let builder._build = builder.build
    1              0.000005   call extend(builder, s:prototype, 'force')
    1              0.000000   return builder

FUNCTION  airline#extensions#tabline#buffers#get()
Called 2 times
Total time:   0.012199
 Self time:   0.000164

count  total (s)   self (s)
    2              0.000002   try
    2   0.000211   0.000009     call <sid>map_keys()
    2              0.000002   catch
                                " no-op
                              endtry
    2              0.000006   let cur = bufnr('%')
    2              0.000004   if cur == s:current_bufnr && &columns == s:column_width
    1              0.000003     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    1              0.000001       return s:current_tabline
                                endif
                              endif
                            
    1   0.000089   0.000013   let b = airline#extensions#tabline#new_builder()
    1              0.000003   let tab_bufs = tabpagebuflist(tabpagenr())
    1              0.000001   let show_buf_label_first = 0
                            
    1              0.000002   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
    1              0.000001   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
                              endif
                            
    1              0.000002   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    1              0.000002   let b.overflow_group = 'airline_tabhid'
    1   0.000207   0.000008   let b.buffers = airline#extensions#tabline#buflist#list()
    1              0.000002   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
    1              0.000001   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    1              0.000004   if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
    1              0.000000   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    1              0.000004   let current_buffer = max([index(b.buffers, cur), 0])
    1              0.000003   let last_buffer = len(b.buffers) - 1
    1   0.000020   0.000005   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    1   0.000006   0.000002   call b.add_section('airline_tabfill', '')
    1   0.000007   0.000002   call b.split()
    1   0.000005   0.000003   call b.add_section('airline_tabfill', '')
    1              0.000001   if !show_buf_label_first
    1   0.000029   0.000007     call airline#extensions#tabline#add_label(b, 'buffers')
    1              0.000001   endif
                            
    1              0.000002   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif
                            
    1              0.000002   let s:current_bufnr = cur
    1              0.000002   let s:column_width = &columns
    1   0.011517   0.000007   let s:current_tabline = b.build()
    1              0.000004   let s:current_visible_buffers = copy(b.buffers)
    1              0.000002   if b._right_title <= last_buffer
                                call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              endif
    1              0.000001   if b._left_title > 0
    1              0.000003     call remove(s:current_visible_buffers, 0, b._left_title)
    1              0.000000   endif
    1              0.000001   return s:current_tabline

FUNCTION  <SNR>91_format_name()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001     return a:name

FUNCTION  <SNR>19_repo_dir()
Called 35 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
   35              0.000282   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>117_tabline_evaluated_length()
Called 7 times
Total time:   0.000714
 Self time:   0.000060

count  total (s)   self (s)
    7   0.000714   0.000060   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>122_discover_supported_filetypes()
Called 4 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
                              " Initialize predefined groups & mappings and discover supported file types.
    4              0.000015   if !s:discovered_filetypes
                                " Discover the file types supported by Exuberant Ctags?
                                let command_line = xolox#easytags#ctags_command()
                                if !empty(command_line)
                                  let starttime = xolox#misc#timer#start()
                                  let command_line .= ' --list-languages'
                                  for line in xolox#misc#os#exec({'command': command_line})['stdout']
                                    if line =~ '\[disabled\]$'
                                      " Ignore languages that have been explicitly disabled using `--languages=-Vim'.
                                      continue
                                    elseif line =~ '^\w\S*$'
                                      call add(s:supported_filetypes, xolox#easytags#filetypes#to_vim(xolox#misc#str#trim(line)))
                                    elseif line =~ '\S'
                                      call xolox#misc#msg#warn("easytags.vim %s: Failed to parse line of output from ctags --list-languages: %s", g:xolox#easytags#version, string(line))
                                    endif
                                  endfor
                                  let msg = "easytags.vim %s: Retrieved %i supported languages in %s."
                                  call xolox#misc#timer#stop(msg, g:xolox#easytags#version, len(s:supported_filetypes), starttime)
                                endif
                                " Add file types supported by language specific programs.
                                call extend(s:supported_filetypes, keys(xolox#misc#option#get('easytags_languages', {})))
                                " Don't run s:discover_supported_filetypes() more than once.
                                let s:discovered_filetypes = 1
                              endif

FUNCTION  <SNR>114_upsert_new_gitgutter_signs()
Called 1 time
Total time:   0.000036
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000010   0.000004   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    1   0.000009   0.000004   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
    1              0.000001   for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  airline#statusline()
Called 13 times
Total time:   0.000398
 Self time:   0.000398

count  total (s)   self (s)
   13              0.000172   if has_key(s:contexts, a:winnr)
   13              0.000197     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#utility#is_active()
Called 7 times
Total time:   0.002579
 Self time:   0.000253

count  total (s)   self (s)
    7   0.002571   0.000245   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>22_exists_file()
Called 7 times
Total time:   0.000991
 Self time:   0.000195

count  total (s)   self (s)
    7   0.000987   0.000191   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#parts#mode()
Called 13 times
Total time:   0.000686
 Self time:   0.000236

count  total (s)   self (s)
   13   0.000677   0.000227   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>106_get_seperator()
Called 10 times
Total time:   0.010703
 Self time:   0.000094

count  total (s)   self (s)
   10   0.002352   0.000033   if airline#builder#should_change_group(a:prev_group, a:group)
    9   0.008343   0.000053     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
    1              0.000003     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  xolox#misc#option#get()
Called 8 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    8              0.000055   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
    8              0.000019     return a:1
                              endif

FUNCTION  <SNR>111_write_buffer()
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000007   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    1              0.000003   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    1              0.000003   let fenc = getbufvar(a:bufnr, '&fileencoding')
    1              0.000002   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    1              0.000002   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
                              endif
                            
    1              0.000034   call writefile(bufcontents, a:file)

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 1 time
Total time:   0.000183
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    1              0.000009     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000000   endif
                            
    1              0.000002   if !empty(colors)
    1   0.000162   0.000006     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    1              0.000000   endif

FUNCTION  xolox#easytags#autoload()
Called 4 times
Total time:   0.004006
 Self time:   0.003125

count  total (s)   self (s)
    4              0.000008   try
    4   0.000100   0.000065     let session_loading = xolox#easytags#session_is_loading() && a:event == 'BufReadPost'
    4   0.000198   0.000054     let do_update = xolox#misc#option#get('easytags_auto_update', 1) && !session_loading
    4   0.000194   0.000074     let do_highlight = xolox#misc#option#get('easytags_auto_highlight', 1) && &eventignore !~? '\<syntax\>'
                                " Don't execute this function for unsupported file types (doesn't load
                                " the list of file types if updates and highlighting are both disabled).
    4   0.000660   0.000078     if (do_update || do_highlight) && !empty(xolox#easytags#filetypes#canonicalize(&filetype))
                                  " Update entries for current file in tags file?
    3              0.000008       if do_update
    3              0.000041         let buffer_read = (a:event =~? 'BufReadPost')
    3              0.000031         let buffer_written = (a:event =~? 'BufWritePost')
    3              0.000023         if buffer_written || (buffer_read && xolox#misc#option#get('easytags_always_enabled', 0))
                                      call xolox#easytags#update(1, 0, [])
                                    endif
    3              0.000005       endif
                                  " Apply highlighting of tags to current buffer?
    3              0.000007       if do_highlight
    3              0.000019         if !exists('b:easytags_last_highlighted')
                                      call xolox#easytags#highlight()
                                    else
    6              0.002405           for tagfile in tagfiles()
    3              0.000041             if getftime(tagfile) > b:easytags_last_highlighted
                                          call xolox#easytags#highlight()
                                          break
                                        endif
    3              0.000005           endfor
    3              0.000004         endif
    3              0.000020         let b:easytags_last_highlighted = localtime()
    3              0.000003       endif
    3              0.000004     endif
    4              0.000007   catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
                              endtry

FUNCTION  <SNR>117_get_separator_change_with_end()
Called 5 times
Total time:   0.001866
 Self time:   0.000104

count  total (s)   self (s)
    5              0.000007   let sep_change = 0
    5              0.000009   if !empty(a:new_end_group) " Separator between title and the end
    4   0.000750   0.000021     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    4              0.000000   endif
    5              0.000009   if !empty(a:old_group) " Separator between the title and the one adjacent
    2   0.000518   0.000010     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
    2              0.000005     if !empty(a:old_end_group) " Remove mis-predicted separator
    2   0.000537   0.000012       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
    2              0.000001     endif
    2              0.000001   endif
    5              0.000004   return sep_change

FUNCTION  airline#extensions#branch#get_head()
Called 13 times
Total time:   0.011624
 Self time:   0.000555

count  total (s)   self (s)
   13   0.011196   0.000127   let head = airline#extensions#branch#head()
   13              0.000105   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   13              0.000103   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   13              0.000201   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  fugitive#head()
Called 13 times
Total time:   0.004442
 Self time:   0.000381

count  total (s)   self (s)
   13              0.000071   if !exists('b:git_dir')
                                return ''
                              endif
                            
   13   0.004305   0.000244   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  288()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000006   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  289()
Called 1 time
Total time:   0.000013
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000004   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    1   0.000008   0.000005   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  <SNR>47_Map()
Called 2 times
Total time:   0.002153
 Self time:   0.000141

count  total (s)   self (s)
                              " Set mappings:
    2              0.000002   try
    2              0.000004     let save_keymap = &keymap
    2              0.000002     let save_iminsert = &iminsert
    2              0.000002     let save_imsearch = &imsearch
    2              0.000010     let save_cpo = &cpo
    2              0.000010     set keymap=
    2              0.000009     set cpo&vim
    2   0.000022   0.000019     silent! doautocmd <nomodeline> User delimitMate_map
    2   0.000046   0.000008     if s:get('autoclose')
    2   0.001548   0.000016       call s:AutoClose()
    2              0.000002     else
                                  call s:NoAutoClose()
                                endif
    2   0.000450   0.000011     call s:ExtraMappings()
    2              0.000002   finally
    2              0.000013     let &cpo = save_cpo
    2              0.000008     let &keymap = save_keymap
    2              0.000007     let &iminsert = save_iminsert
    2              0.000004     let &imsearch = save_imsearch
    2              0.000001   endtry
                            
    2              0.000003   let b:delimitMate_enabled = 1

FUNCTION  airline#extensions#ctrlp#apply()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    1              0.000005   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#extensions#hunks#get_hunks()
Called 13 times
Total time:   0.004063
 Self time:   0.002196

count  total (s)   self (s)
   13              0.000086   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
   13              0.000393   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
   13   0.001997   0.000130   let hunks = s:get_hunks()
   13              0.000036   let string = ''
   13              0.000055   if !empty(hunks)
   48              0.000141     for i in [0, 1, 2]
   36              0.000360       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
    9              0.000163         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
    9              0.000016       endif
   36              0.000052     endfor
   12              0.000021   endif
   13              0.000057   let b:airline_hunks = string
   13              0.000060   let b:airline_changenr = b:changedtick
   13              0.000064   let s:airline_winwidth = winwidth(0)
   13              0.000034   return string

FUNCTION  airline#parts#iminsert()
Called 13 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
   13              0.000068   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   13              0.000022   return ''

FUNCTION  290()
Called 10 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
   10              0.000026   call add(self._sections, [a:group, a:contents])

FUNCTION  292()
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000011   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  <SNR>86_invoke_funcrefs()
Called 1 time
Total time:   0.008391
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000028   0.000009   let builder = airline#builder#new(a:context)
    1   0.000752   0.000010   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    1              0.000001   if err == 1
    1   0.007598   0.000007     let a:context.line = builder.build()
    1              0.000004     let s:contexts[a:context.winnr] = a:context
    1              0.000006     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    1              0.000001   endif

FUNCTION  295()
Called 3 times
Total time:   0.015738
 Self time:   0.001210

count  total (s)   self (s)
    3              0.000004   let side = 1
    3              0.000002   let line = ''
    3              0.000002   let i = 0
    3              0.000006   let length = len(self._sections)
    3              0.000002   let split = 0
    3              0.000003   let is_empty = 0
    3              0.000002   let prev_group = ''
                            
   22              0.000025   while i < length
   19              0.000033     let section = self._sections[i]
   19              0.000030     let group = section[0]
   19              0.000024     let contents = section[1]
   19              0.000019     let pgroup = prev_group
   19   0.000250   0.000082     let prev_group = airline#builder#get_prev_group(self._sections, i)
   19              0.000030     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
   19              0.000009     if is_empty
                                  let prev_group = pgroup
                                endif
   19   0.000220   0.000074     let is_empty = s:section_is_empty(self, contents)
                            
   19              0.000014     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   19              0.000015     if group == ''
                                  let line .= contents
                                elseif group == '|'
    3              0.000003       let side = 0
    3              0.000003       let line .= contents
    3              0.000003       let split = 1
    3              0.000002     else
   16              0.000013       if prev_group == ''
    3              0.000007         let line .= '%#'.group.'#'
    3              0.000001       elseif split
    3              0.000003         if !is_empty
    3   0.002953   0.000012           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    3              0.000003         endif
    3              0.000003         let split = 0
    3              0.000001       else
   10              0.000008         if !is_empty
   10   0.010754   0.000051           let line .= s:get_seperator(self, prev_group, group, side)
   10              0.000006         endif
   10              0.000003       endif
   16   0.000672   0.000102       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   16              0.000010     endif
                            
   19              0.000032     let i = i + 1
   19              0.000011   endwhile
                            
    3              0.000003   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    3              0.000005   return line

FUNCTION  296()
Called 1 time
Total time:   0.000015
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002   let self._first_title = a:first " lowest index
    1              0.000002   let self._last_title = a:last " highest index
    1              0.000001   let self._left_title = a:current " next index to add on the left
    1              0.000002   let self._right_title = a:current + 1 " next index to add on the right
    1   0.000007   0.000004   let self._left_position = self.get_position() " left end of titles
    1              0.000001   let self._right_position = self._left_position " right end of the titles

FUNCTION  297()
Called 3 times
Total time:   0.000875
 Self time:   0.000097

count  total (s)   self (s)
    3   0.000270   0.000011   let title = self.get_title(a:index)
    3   0.000526   0.000014   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    3              0.000006   if a:force || self._remaining_space >= title_size
    2              0.000002     let pos = a:pos
    2              0.000003     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
                                endif
                            
    2   0.000018   0.000011     call self.insert_section(a:group, title, pos)
    2              0.000003     let self._right_position += 1
    2              0.000002     let pos += 1
                            
    2              0.000003     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
                                endif
                            
    2              0.000002     let self._remaining_space -= title_size
    2              0.000002     return 1
                              endif
    1              0.000001   return 0

FUNCTION  298()
Called 1 time
Total time:   0.011510
 Self time:   0.000247

count  total (s)   self (s)
    1              0.000003   if has_key(self, '_left_position') && self._first_title <= self._last_title
    1   0.003087   0.000016     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    1              0.000003     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    1   0.000038   0.000004     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    1   0.000035   0.000004     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    1   0.000014   0.000004     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    1   0.000032   0.000013     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    1              0.000004     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    1   0.000038   0.000004     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    1              0.000002     if self._left_title > self._first_title
    1   0.000041   0.000009       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000001     endif
    1              0.000001     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
    1   0.000047   0.000004     let group = self.get_group(self._left_title)
    1              0.000001     if self._left_title == self._first_title
                                  let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
    1   0.000275   0.000004       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000001     endif
    1              0.000001     if self._left_title == self._last_title
    1   0.000268   0.000006       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    1              0.000002     let left_group = group
    1              0.000001     let right_group = group
    1   0.000331   0.000010     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    1              0.000002     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
    1              0.000002     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
    2              0.000002     while self._remaining_space > 0
    2              0.000002       let done = 0
    2              0.000002       if self._left_title >= self._first_title
                                    " Insert next title to the left
    2   0.000066   0.000007         let group = self.get_group(self._left_title)
    2              0.000002         if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
    2   0.001349   0.000010           let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
    2              0.000002         endif
    2              0.000003         let left_group = group
    2   0.000565   0.000011         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
    2              0.000003         let self._left_title -= done
    2              0.000001       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    2              0.000004       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
    2              0.000002       if !done
    1              0.000001         break
                                  endif
    1              0.000001     endwhile
                            
    1              0.000002     if self._left_title >= self._first_title
    1              0.000002       if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
    1   0.000009   0.000005       call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
    1              0.000001       let self._right_position += 1
    1              0.000001     endif
                            
    1              0.000001     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
    1              0.000000   endif
                            
    1   0.005183   0.000004   return self._build()

FUNCTION  gitgutter#utility#getbufvar()
Called 29 times
Total time:   0.000516
 Self time:   0.000516

count  total (s)   self (s)
   29              0.000259   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   29              0.000128   if has_key(dict, a:varname)
   26              0.000088     return dict[a:varname]
                              else
    3              0.000002     if a:0
    1              0.000001       return a:1
                                endif
    2              0.000000   endif

FUNCTION  airline#util#prepend()
Called 13 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
   13              0.000073   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   13              0.000090   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>15_on_window_changed()
Called 2 times
Total time:   0.008526
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000007   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    2              0.000019   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    2              0.000025   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    1              0.000000     return
                              endif
    1              0.000002   let g:airline_last_window_changed = l:key
    1   0.000008   0.000005   call s:init()
    1   0.008453   0.000009   call airline#update_statusline()

FUNCTION  <SNR>47_set()
Called 46 times
Total time:   0.001010
 Self time:   0.000152

count  total (s)   self (s)
   46   0.001005   0.000147   return call('delimitMate#Set', a:000)

FUNCTION  airline#builder#new()
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000018   let builder = copy(s:prototype)
    2              0.000003   let builder._context = a:context
    2              0.000003   let builder._sections = []
                            
    2              0.000015   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    2              0.000002   return builder

FUNCTION  <SNR>91_update_git_branch()
Called 13 times
Total time:   0.005089
 Self time:   0.000550

count  total (s)   self (s)
   13   0.000194   0.000097   if !s:has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
   13   0.004636   0.000194   let s:vcs_config['git'].branch = fugitive#head(s:sha1size)
   13              0.000090   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 1 time
Total time:   0.000043
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000016   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    1   0.000025   0.000011   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>102_hl_group_exists()
Called 160 times
Total time:   0.002273
 Self time:   0.002273

count  total (s)   self (s)
  160              0.000832   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
    2              0.000001     return 0
                              endif
  158              0.000096   return 1

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   1.903146   0.000448  <SNR>11_SynSet()
  147   1.867827   0.008772  <SNR>140_SetNamedColor()
  294   1.856463   0.893504  <SNR>140_Rgb2xterm()
224910   0.962959             <SNR>140_pow()
   13   0.035728   0.002412  airline#check_mode()
    1   0.033133   0.003441  airline#highlighter#highlight()
  296   0.031601   0.013365  airline#highlighter#get_highlight()
  160   0.027371   0.006864  airline#highlighter#exec()
   51   0.021837   0.001412  <SNR>102_exec_separator()
  592   0.016318             <SNR>102_get_syn()
    3   0.015738   0.001210  295()
    2   0.012262   0.000063  airline#extensions#tabline#get()
    2   0.012199   0.000164  airline#extensions#tabline#buffers#get()
  102   0.011717   0.000448  airline#themes#get_highlight()
   13   0.011624   0.000555  airline#extensions#branch#get_head()
    1   0.011510   0.000247  298()
   12   0.011231   0.000344  <SNR>106_get_transitioned_seperator()
   13   0.011069   0.000723  airline#extensions#branch#head()
   24   0.010887   0.000235  airline#highlighter#add_separator()
   10   0.010703   0.000094  <SNR>106_get_seperator()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
224910              0.962959  <SNR>140_pow()
  294   1.856463   0.893504  <SNR>140_Rgb2xterm()
  592              0.016318  <SNR>102_get_syn()
  296   0.031601   0.013365  airline#highlighter#get_highlight()
  147   1.867827   0.008772  <SNR>140_SetNamedColor()
  160   0.027371   0.006864  airline#highlighter#exec()
    1   0.006510   0.005441  gitgutter#diff#run_diff()
  255              0.004665  <SNR>140_Xterm2rgb()
    1   0.033133   0.003441  airline#highlighter#highlight()
    4   0.004006   0.003125  xolox#easytags#autoload()
   13   0.003629   0.002813  airline#extensions#whitespace#check()
  147              0.002592  <SNR>140_FGforBG()
   13   0.035728   0.002412  airline#check_mode()
  160              0.002273  <SNR>102_hl_group_exists()
    1   0.007326   0.002247  <SNR>8_LoadFTPlugin()
   13   0.002613   0.002240  <SNR>91_update_untracked()
   13   0.004063   0.002196  airline#extensions#hunks#get_hunks()
  296              0.001918  <SNR>102_get_array()
   91              0.001829  airline#util#append()
    3              0.001771  <SNR>71_Highlight_Matching_Pair()

